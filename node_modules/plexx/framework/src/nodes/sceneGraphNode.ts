namespace Plexx {
    export abstract class SceneGraphNode {
        private id: number = 0;
        private name: string;
        private childNodes: Array<SceneGraphNode>;
        private parentNode: SceneGraphNode;
        private values: any;
        private rootNode: DrawingArea;

        constructor(name: string) {
            this.name = name;
            this.childNodes = [];
            this.parentNode = null;
            this.rootNode = null;
        }

        public abstract accept(nodeVisitor: NodeVisitorInterface): any;

        public abstract  clone(): Plexx.SceneGraphNode;

        public add(node: SceneGraphNode) {
            node.parentNode = this;

            if (this instanceof DrawingArea) {
                node.setRootNode(this);
            }

            this.childNodes.push(node);
        }

        public getChildren(): Array<SceneGraphNode> {
            return this.childNodes;
        }

        public getName() {
            return this.name;
        }

        public static mergeInterfaces<T>(valueList: T, defaultValueList: T): T {
            let mergedValues: T = valueList;
            for (let key in defaultValueList) {
                if (defaultValueList.hasOwnProperty(key) && !valueList.hasOwnProperty(key)) {
                    mergedValues[key] = defaultValueList[key];
                }
            }
            return mergedValues;
        }

        public toString(): string {
            let text = this.getName() + " { ";
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key)) {
                    text += key + ": " + this.values[key] + "; ";
                }
            }
            text += "}";
            return text;
        }

        public setValues<T>(values: T) {
            this.values = <T> values;
        }

        protected setParent(parentNode: SceneGraphNode) {
            this.parentNode = parentNode;
            if (parentNode.getRootNode() !== null) {
                this.rootNode = parentNode.getRootNode();
            }
        }

        protected setRootNode(rootNode: DrawingArea) {
            this.rootNode = rootNode;
            this.childNodes.forEach(childNode => {
                childNode.setRootNode(rootNode);
            });
        }

        protected getRootNode() {
            return this.rootNode;
        }
    }
}
