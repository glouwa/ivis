/// <reference path="../helper/references.ts" />

namespace Plexx {
    export interface DrawingAreaInterface {
        width: number;
        height: number;
        align?: AlignOptions;
        background?: string;
    }

    export type AlignOptions = "none"
        | "xMinYMin"
        | "xMinYMid"
        | "xMinYMax"
        | "xMidYMin"
        | "xMidYMid"
        | "xMidYMax"
        | "xMaxYMin"
        | "xMaxYMid"
        | "xMaxYMax";

    // export class Instances {
    //     static instance: Instances = new Instances();
    //
    //     private plexxInstances: { [domId: string]: DrawingArea} = {};
    //
    //     static getI(): Instances {
    //         return Instances.instance;
    //     }
    //
    //     constructor() {
    //         Instances.instance = this;
    //         Instances.instance.plexxInstances = this.plexxInstances;
    //     }
    //
    //     addInstance(domId: string, drawingArea: DrawingArea) {
    //         this.plexxInstances[domId] = drawingArea;
    //     }
    //
    //     // getInstance(domId: string): DrawingArea {
    //     //     return this.plexxInstances[domId];
    //     // }
    // }

    export class DrawingArea extends Plexx.CompositeNode {
        public renderContext: RenderContext;
        public eventQueue: Array<MouseEvent> = [];

        public translationNode: Plexx.TranslationNode;
        public rotationNode: Plexx.RotationNode;
        public scaleNode: Plexx.ScaleNode;

        public x: number;
        public y: number;

        private width: number;
        private height: number;
        private background: string;
        private align: AlignOptions;

        private canvasColour: Plexx.Colour;
        private lastTimeRendered: Date;
        private renderTime: number;
        private currentFramesPerSecond: number;
        private frameCounter: number = 0;

        private lastState: PlexxEvent = new PlexxEvent("none", new Plexx.Mathlib.Vec2(0, 0));
        private newState: PlexxEvent;

        public constructor(values: DrawingAreaInterface) {
            super("DrawingArea");

            this.width = values.width;
            this.height = values.height;
            this.align = values.align || "xMidYMid";
            this.background = values.background || "#FFFFFF";

            this.canvasColour = new Colour(this.background);

            this.setRootNode(this);

            this.translationNode = new TranslationNode({});
            this.scaleNode = new ScaleNode({});
            this.rotationNode = new RotationNode({});
        }

        public clone(): Plexx.DrawingArea {
            return new Plexx.DrawingArea({
                width: this.width,
                height: this.height,
                align: this.align,
                background: this.background
            });
        }

        public toString() {
            let text = this.getName() + " { ";

            text += "width: " + this.width + "; ";
            text += "height: " + this.height + "; ";
            text += "background: " + this.background + "; ";
            text += "align: " + this.align + "; ";

            return text;
        }

        public renderSingleFrame(renderContext: Plexx.RenderContext) {
            this.init(renderContext);
            this.accept(new Plexx.RenderNodeVisitor(renderContext));
        }

        public accept(nodeVisitor: Plexx.NodeVisitorInterface): any {
            return nodeVisitor.visitDrawingAreaNode(this);
        }

        public run(renderContext: Plexx.RenderContext) {
            this.init(renderContext);
            this.renderFrame(renderContext);
        }

        private init(renderContext: Plexx.RenderContext) {
//            Instances.getI().addInstance(renderContext.getId(), this);

            let currentRenderType: RenderType;

            this.renderContext = renderContext;


            renderContext.setHeight(this.height);
            renderContext.setWidth(this.width);
            renderContext.setCanvasNode(this);

            currentRenderType = renderContext.getRenderType();
            renderContext.changeRenderType(currentRenderType);

            this.resizePlexx();
            switch (currentRenderType) {
                case RenderType.CANVAS2D:
                    this.initCanvas2d(renderContext);
                    break;
                case RenderType.SVG:
                    this.initSvg(renderContext);
                    break;
                case RenderType.WEBGL:
                    this.initWebGl(renderContext);
                    break;
            }
            this.accept(new Plexx.InitNodeVisitor(renderContext));
            this.accept(new Plexx.RenderNodeVisitor(renderContext));

            window.addEventListener("resize", this.resizePlexx.bind(this), false);
        }

        private renderFrame(renderContext: Plexx.RenderContext) {
            requestAnimationFrame(() => this.renderFrame(renderContext));
            let currentMouseEvent: MouseEvent = null;
            let currentTime = new Date();

            if (!this.lastTimeRendered) this.lastTimeRendered = currentTime;
            this.renderTime = (currentTime.getTime() - this.lastTimeRendered.getTime()) / 1000;
            this.frameCounter += 1;

            if (this.renderTime >= 1.0) {
                this.currentFramesPerSecond = this.frameCounter;
                this.frameCounter = 0;
                this.lastTimeRendered = currentTime;
            }

            if (this.eventQueue.length > 0) {
                while (this.eventQueue.length > 0) {
                    currentMouseEvent = this.eventQueue.shift();
                    this.newState = this.accept(new ClickNodeVisitor(renderContext, currentMouseEvent, this.lastState));
                    this.lastState = this.newState;
                }
                this.accept(new Plexx.RenderNodeVisitor(renderContext));
            }
        }

        private static getMousePosition(canvas: HTMLCanvasElement, evt: any, renderContext: RenderContext): Plexx.Mathlib.Vec2 {
            let rect = canvas.getBoundingClientRect();
            let mousePosition = new Plexx.Mathlib.Vec2(0, 0);

            mousePosition.x = Math.round((evt.clientX - rect.left) / (rect.right - rect.left) * renderContext.getWidth());
            mousePosition.y = renderContext.getHeight() - Math.round((evt.clientY - rect.top) / (rect.bottom - rect.top) * renderContext.getHeight());

            return mousePosition;
        }

        private resizePlexx() {
            let clientHeight: number = this.renderContext.getClientHeight();
            let clientWidth: number = this.renderContext.getClientWidth();
            let scale: number[] = [];
            let scaleX: number = 0;
            let scaleY: number = 0;

            if (this.align === "none") {
                scaleX = clientWidth / this.width;
                scaleY = clientHeight / this.height;
                scale = [scaleX, scaleY];
                this.renderContext.setWidth(clientWidth);
                this.renderContext.setHeight(clientHeight);
                this.scaleNode = new ScaleNode({
                    scale: scale
                });
                this.renderContext.setStylePosition("relative");
                this.renderContext.setStyleTop(String(0) + "px");
                this.renderContext.setStyleLeft(String(0) + "px");
            } else {
                if (this.height * clientWidth / this.width > clientHeight) {
                    scaleY = clientHeight / this.height;
                    scale = [scaleY, scaleY];
                    this.renderContext.setWidth(this.width * scaleY);
                    this.renderContext.setHeight(clientHeight);
                    this.scaleNode = new ScaleNode({
                        scale: scale
                    });
                }
                else {
                    scaleX = clientWidth / this.width;
                    scale = [scaleX, scaleX];
                    this.renderContext.setWidth(clientWidth);
                    this.renderContext.setHeight(this.height * scaleX);
                    this.scaleNode = new ScaleNode({
                        scale: scale
                    });
                }

                this.renderContext.setStylePosition("relative");

                if (this.align.substring(1, 4) === "Min") {
                    this.renderContext.setStyleLeft(String(0) + "px");
                }
                else if (this.align.substring(1, 4) === "Mid") {
                    this.renderContext.setStyleLeft(String((clientWidth - this.width * scale[0]) / 2) + "px");
                }
                else if (this.align.substring(1, 4) === "Max") {
                    this.renderContext.setStyleLeft(String(clientWidth - this.width * scale[0]) + "px");
                }

                if (this.align.substring(5, 8) === "Min") {
                    this.renderContext.setStyleTop(String(clientHeight - this.height * scale[1]) + "px");
                }
                else if (this.align.substring(5, 8) === "Mid") {
                    this.renderContext.setStyleTop(String((clientHeight - this.height * scale[1]) / 2) + "px");
                }
                else if (this.align.substring(5, 8) === "Max") {
                    this.renderContext.setStyleTop(String(0) + "px");
                }
            }
            // this.init(this.renderContext);
            // this.renderContext.initWebGLCanvas();

//            this.initWebGl(this.renderContext);
//            this.initWebGl(this.renderContext);
            this.accept(new Plexx.InitNodeVisitor(this.renderContext));
            this.accept(new Plexx.RenderNodeVisitor(this.renderContext));
        }

        private initCanvas2d(renderContext: RenderContext) {
            let self: DrawingArea = this;

            // add event listener
            let mouseEventTypes: MouseEventType[] = ["mousemove", "mousedown", "mouseup", "mouseleave", "click"];

            for (let index = 0; index < mouseEventTypes.length; index++) {
                let mouseEventType: MouseEventType = mouseEventTypes[index];
                renderContext.getCanvas2D().addEventListener(mouseEventType, function (evt: any) {
                    let mousePosition = Plexx.DrawingArea.getMousePosition(renderContext.getCanvas2D(), evt, renderContext);
                    self.eventQueue.push(new MouseEvent(mouseEventType, mousePosition));
                }, false);
            }

            // intitialize background
            renderContext.getCanvas2D().style.backgroundColor = this.canvasColour.getRGBString();
        }

        private initWebGl(renderContext: RenderContext) {
            let self: DrawingArea = this;

            // add event listener
            let mouseEventTypes: MouseEventType[] = ["mousemove", "mousedown", "mouseup", "mouseleave", "click"];

            for (let index = 0; index < mouseEventTypes.length; index++) {
                let mouseEventType: MouseEventType = mouseEventTypes[index];
                renderContext.getCanvasWebGL().addEventListener(mouseEventType, function (evt: any) {
                    let mousePosition = Plexx.DrawingArea.getMousePosition(renderContext.getCanvasWebGL(), evt, renderContext);
                    self.eventQueue.push(new MouseEvent(mouseEventType, mousePosition));
                }, false);
            }

            // initialize render context
            let gl = <WebGLRenderingContext> renderContext.getCanvasWebGL().getContext("webgl", {stencil: true});

            gl.clearColor(this.canvasColour.getR() * this.canvasColour.getA(), this.canvasColour.getG() * this.canvasColour.getA(), this.canvasColour.getB() * this.canvasColour.getA(), this.canvasColour.getA());

            // enable alpha blending
            gl.enable(gl.BLEND);

            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);

            // set blend function
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        }

        private initSvg(renderContext: RenderContext) {
            let self: DrawingArea = this;

            // add event listener
            let mouseEventTypes: MouseEventType[] = ["mousemove", "mousedown", "mouseup", "mouseleave", "click"];

            for (let index = 0; index < mouseEventTypes.length; index++) {
                let mouseEventType: MouseEventType = mouseEventTypes[index];
                renderContext.getSVG().addEventListener(mouseEventType, function (evt: any) {
                    let mousePosition = Plexx.DrawingArea.getMousePosition(renderContext.getSVG(), evt, renderContext);
                    self.eventQueue.push(new MouseEvent(mouseEventType, mousePosition));
                }, false);
            }

            renderContext.setCanvasNode(this);
            renderContext.getSVG().setAttributeNS(null, "preserveAspectRatio", "" + "none");
            renderContext.getSVG().setAttributeNS(null, "shape-rendering", "geometricPrecision");
            renderContext.getSVG().style.background = this.canvasColour.getRGBString();
        }

        public static clearCanvas2d(renderContext: RenderContext): boolean {
            renderContext.getCanvas2dContext().clearRect(0, 0, renderContext.getCanvas2D().width, renderContext.getCanvas2D().height);
            return true;
        }

        public updateCanvas2d(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): number {
            renderContext.getCanvas2dContext().clearRect(0, 0, renderContext.getCanvas2D().width, renderContext.getCanvas2D().height);
            let currentRenderType = renderContext.getRenderType();
            let currentTime = new Date();
//            this.renderTime = (currentTime.getTime() - this.lastTimeRendered.getTime()) / 1000;
            return 0;
        }

        public updateSvg(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): number {
            this.lastTimeRendered = new Date();
//            renderContext.setCanvasNode(this);
//            renderContext.getSVG().setAttributeNS(null, "preserveAspectRatio", "" + "none");
//            renderContext.getSVG().setAttributeNS(null, "width", "" + this.width);
//            renderContext.getSVG().setAttributeNS(null, "height", "" + this.height);
//            renderContext.getSVG().setAttributeNS(null, "shape-rendering", "geometricPrecision");
//            renderContext.getSVG().setAttributeNS(null, "style", "display:block; width: 100%; height: 100%; background: " + this.canvasColour.getRGBString());
//            let currentRenderType = renderContext.getRenderType();
            let currentTime = new Date();
            this.renderTime = (currentTime.getTime() - this.lastTimeRendered.getTime()) / 1000;
            return 0;
        }

        public updateWebGl(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): number {
            this.lastTimeRendered = new Date();
            renderContext.setCanvasNode(this);
//           renderContext.getCanvasWebGL().setAttribute("height", this.renderContext.getHeight());
//           renderContext.getCanvasWebGL().setAttribute("width", this.renderContext.getWidth());

            let gl = <WebGLRenderingContext> renderContext.getWebGLRenderingContext();

            gl.clearColor(this.canvasColour.getR() * this.canvasColour.getA(), this.canvasColour.getG() * this.canvasColour.getA(), this.canvasColour.getB() * this.canvasColour.getA(), this.canvasColour.getA());
            gl.clear(gl.COLOR_BUFFER_BIT);

            // enable alpha blending
            gl.enable(gl.BLEND);

            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);

            // set blend function
            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.viewport(0, 0, this.renderContext.getWidth(), this.renderContext.getHeight());
            // let currentRenderType = renderContext.getRenderType();
            let currentTime = new Date();
            this.renderTime = (currentTime.getTime() - this.lastTimeRendered.getTime()) / 1000;
            return 0;
        }

        public generateSvg(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): XMLTag {
            let xmlTag = new XMLTag("svg");

//            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
//            let resultMatrix: Plexx.Mathlib.Mat3 = preTransformationMatrix.copy().multiply(mirrorMatrix);

            xmlTag.addAttribute("viewBox", "0 0 " + renderContext.getWidth() + " " + renderContext.getHeight());
            xmlTag.addAttribute("version", "1.1");
            xmlTag.addAttribute("baseProfile", "full");
            xmlTag.addAttribute("xmlns", "http://www.w3.org/2000/svg");
            xmlTag.addAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
            xmlTag.addAttribute("preserveAspectRatio", "" + "xMidyMid");
//            xmlTag.addAttribute("width", "" + this.width);
//            xmlTag.addAttribute("height", "" + this.height);
            xmlTag.addAttribute("shape-rendering", "geometricPrecision");
//            xmlTag.addAttribute("style", "width: 100%; height: 100%; background: " + this.canvasColour.getRGBString());
//            xmlTag.addAttribute("transform", "matrix(" + resultMatrix.at(0) + " " + resultMatrix.at(1) + " " + resultMatrix.at(3) + " " + resultMatrix.at(4) + " " + resultMatrix.at(6) + " " + resultMatrix.at(7) + ")");

            return xmlTag;
        }

        public getHeight(): number {
            return this.height;
        }

        public getWidth(): number {
            return this.width;
        }

        public getClientWidth(): number {
            return this.renderContext.getClientWidth();
        }

        public getClientHeight(): number {
            return this.renderContext.getClientHeight();
        }

        public getColour(): string {
            return this.canvasColour.getCss3String();
        }

        public toSVGString(renderContext: RenderContext): string {
            let svgString: string = "";
            let xmlTag = new XMLTag("svg");

            svgString = svgString + xmlTag.getEndTag() + "\n";

            return svgString;
        }

        public getCurrentFramesPerSeconds(): number {
            return this.currentFramesPerSecond;
        }

        public getBackgroundColor(): string {
            return this.background;
        }
    }
}
