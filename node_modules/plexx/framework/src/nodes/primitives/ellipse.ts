/// <reference path="../../helper/references.ts" />

namespace Plexx {

    export interface EllipseInterface extends Plexx.TransformationsInterface {
        radiusX: number;
        radiusY: number;
        position: number[];
        colour?: string;
    }

    export class Ellipse extends Plexx.PrimitiveNode implements EllipseInterface {

        public radiusX: number;
        public radiusY: number;
        public position: number[];
        public colour: string;

        private colourNode: Colour;

        private circleSides = 128;

        constructor(values: EllipseInterface) {
            super("Ellipse", values);

            this.radiusX = values.radiusX;
            this.radiusY = values.radiusY;
            this.position = values.position;
            this.colour = values.colour;
            this.colourNode = new Colour(this.colour);

            console.log("[FDGL] " + this.toString() + " created");
        }

        public toString(): string {
            let ellipseString = this.getName() + " { ";

            ellipseString += "radiusX: " + this.radiusX + "; ";
            ellipseString += "radiusY: " + this.radiusY + "; ";
            ellipseString += "position: " + this.position + "; ";
            ellipseString += "colour: " + this.position + "; ";
            ellipseString += "}";

            return ellipseString;
        }

        public setColour(colour: string) {
            this.colourNode.setColour(colour);
        }

        public updateCanvas2d(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let context = renderContext.getCanvas2D().getContext("2d");

            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = preTransformationMatrix.copy().multiply(mirrorMatrix);

            context.save();
            context.beginPath();
            context.setTransform(resultMatrix.at(0), resultMatrix.at(1), resultMatrix.at(3), resultMatrix.at(4), resultMatrix.at(6), resultMatrix.at(7));
            context.translate(this.position[0], this.position[1]);
            context.scale(this.radiusX, this.radiusY);
            context.arc(0, 0, 1, 0, 2 * Math.PI, false);
            context.fillStyle = this.colourNode.getCss3String();
            context.fill();
            context.strokeStyle = "none"
            context.closePath();
            context.restore();

            return true;
        }

        public hitBox(renderContext: RenderContext, position: Plexx.Mathlib.Vec2): boolean {
            let x: number = position.x;
            let y: number = position.y;

            if (Math.pow((x - this.position[0]), 2) / Math.pow(this.radiusX, 2) + Math.pow((y - this.position[1]), 2) / Math.pow(this.radiusY, 2) < 1) {
                return true;
            }
            else return false;
        }

        public generateSvg(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): Plexx.XMLTag {

            let xmlTag = new XMLTag("ellipse");
            let SVGObject = document.createElementNS(Constants.SVG_NAMESPACE, "ellipse");
            let canvasHeight = renderContext.getHeight();

            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = preTransformationMatrix.copy().multiply(mirrorMatrix);

            xmlTag.addAttribute("cx", String(this.position[0]));
            xmlTag.addAttribute("cy", String(this.position[1]));
            xmlTag.addAttribute("rx", String(this.radiusX));
            xmlTag.addAttribute("ry", String(this.radiusY));
            xmlTag.addAttribute("fill", this.colourNode.getCss3String());
            xmlTag.addAttribute("transform", "matrix(" + resultMatrix.at(0) + " " + resultMatrix.at(1) + " " + resultMatrix.at(3) + " " + resultMatrix.at(4) + " " + resultMatrix.at(6) + " " + resultMatrix.at(7) + ")");
            xmlTag.addAttribute("stroke", "none");

            return xmlTag;
        }

        public updateWebGl(renderContext: RenderContext, transformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let gl: WebGLRenderingContext = renderContext.getWebGLRenderingContext();

            gl.useProgram(this.shaderProgram);
            let positionLocation = gl.getAttribLocation(this.shaderProgram, "aVertexPosition");

            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            let resolutionLocation = gl.getUniformLocation(this.shaderProgram, "resolution");
            // console.log(resolutionLocation);
            gl.uniform2f(resolutionLocation, renderContext.getCanvasWebGL().getAttribute("width"), renderContext.getCanvasWebGL().getAttribute("height"));

            let tM = new Float32Array(transformationMatrix.all());
            let matrix = gl.getUniformLocation(this.shaderProgram, "matrix");
            gl.uniformMatrix3fv(matrix, false, tM);

            let colourValues = gl.getUniformLocation(this.shaderProgram, "colour");
            gl.uniform4f(colourValues, this.colourNode.getR(), this.colourNode.getG(), this.colourNode.getB(), this.colourNode.getA());

            let polygonVertices = new Float32Array(2 * (this.circleSides));
            let canvasHeight = renderContext.getHeight();

            for (var i = 0; i < this.circleSides; i++) {
                polygonVertices[2 * i] = this.radiusX * Math.cos(2 * Math.PI / this.circleSides * i) + this.position[0];
                polygonVertices[(2 * i) + 1] = this.radiusY * Math.sin(2 * Math.PI / this.circleSides * i) + this.position[1];
            }

            gl.bufferData(gl.ARRAY_BUFFER, polygonVertices, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, this.circleSides);
            return true;
        }

    }
}
