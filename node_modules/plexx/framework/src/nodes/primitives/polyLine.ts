/// <reference path="../../helper/references.ts" />

namespace Plexx {

    import Vec2 = Plexx.Mathlib.Vec2;

    export class Line2D {
        public a: Vec2;
        public b: Vec2;

        constructor(a: Vec2, b: Vec2) {
            this.a = a;
            this.b = b;
        }

        copy(): Line2D {
            return new Line2D(new Vec2(this.a.x, this.a.y), new Vec2(this.b.x, this.b.y));
        }

        public intersect(l: Line2D): Vec2 {
            let p: Vec2 = new Vec2(0, 0);
            let x1: number = this.a.x;
            let y1: number = this.a.y;
            let x2: number = this.b.x;
            let y2: number = this.b.y;
            let x3: number = l.a.x;
            let y3: number = l.a.y;
            let x4: number = l.b.x;
            let y4: number = l.b.y;

            p.x = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
            p.y = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));

            return p;
        }

        public parallelTranslate(s: number) {
            let phi = 90 + (Math.atan2(this.b.y - this.a.y, this.b.x - this.a.x) / (Math.PI)) * 180;
            console.log("phi", phi);
            let xDiff = s * Math.cos(phi * Math.PI / 180);
            console.log("xDiff", xDiff);
            let yDiff = s * Math.sin(phi * Math.PI / 180);
            console.log("yDiff", yDiff);
            console.log("point a", this.a);
            console.log("point b", this.b);
            this.a.x += xDiff;
            this.a.y += yDiff;
            this.b.x += xDiff;
            this.b.y += yDiff;
            console.log("point a", this.a);
            console.log("point b", this.b);
        }
    }

    export interface PolyLineInterface extends Plexx.TransformationsInterface {
        points: number[];
        width?: number;
        type?: string;
        colour?: string;
    }

    export class PolyLine extends Plexx.Group {
        private points: number[];
        private width: number;
        private type: string;
        private colour: string;
        private colourNode: Colour;
        private polygonNode: Plexx.Polygon;

        constructor(values: PolyLineInterface) {
            super({name: "PolyLine"});

            if (values.points.length % 2 !== 0) {
                this.points = values.points.filter(function (value, index, array) {
                    return index < (values.points.length - 1);
                });
            }
            else this.points = values.points;

            this.width = values.width || Constants.DEFAULT_HEIGHT;
            this.type = values.type || Constants.PolyLineTyp.Default;
            this.colour = values.colour;
            this.colourNode = new Colour(this.colour);

            let polygonPoints: Vec2[] = [];
            let firstPoint: Vec2 = new Vec2(this.points[0], this.points[1]);
            let secondPoint: Vec2 = new Vec2(this.points[2], this.points[3]);
            let firstCenterLine: Line2D = new Line2D(firstPoint, secondPoint);
            let firstTopLine: Line2D = firstCenterLine.copy();
            let firstBottomLine: Line2D = firstCenterLine.copy();
            firstTopLine.parallelTranslate(this.width / 2);
            firstBottomLine.parallelTranslate(-this.width / 2);
            polygonPoints.push(firstTopLine.a);
            polygonPoints.push(firstBottomLine.a);

            let oldLeftLine: Line2D = firstTopLine;
            let oldRightLine: Line2D = firstBottomLine;

            for (let i: number = 1; i < (this.points.length / 2) - 1; i++) {
                let currentCenterLine: Line2D = new Line2D(new Vec2(this.points[2 * i], this.points[2 * i + 1]), new Vec2(this.points[2 * i + 2], this.points[2 * i + 3]));
                let currentLeftLine: Line2D = currentCenterLine.copy();
                let currentRightLine: Line2D = currentCenterLine.copy();

                currentLeftLine.parallelTranslate(this.width / 2);
                currentRightLine.parallelTranslate(-this.width / 2);
                polygonPoints.push(oldLeftLine.intersect(currentLeftLine));
                polygonPoints.push(oldRightLine.intersect(currentRightLine));

                oldLeftLine = currentLeftLine;
                oldRightLine = currentRightLine;
            }

            polygonPoints.push(oldLeftLine.b);
            polygonPoints.push(oldRightLine.b);

            let pointsClockwiseFirstSegment: Vec2[] = [];
            let pointsClockwiseSecondSegment: Vec2[] = [];
            pointsClockwiseFirstSegment = polygonPoints.filter(function (value, index, array) {
                return index % 2 === 0;
            });
            pointsClockwiseSecondSegment = polygonPoints.filter(function (value, index, array) {
                return index % 2 !== 0;
            });
            console.log(pointsClockwiseSecondSegment[0]);
            pointsClockwiseSecondSegment = pointsClockwiseSecondSegment.reverse();
            console.log(pointsClockwiseSecondSegment[0]);
            let polygonPointsClockwise: Vec2[] = [];
            for (let i = 0; i < pointsClockwiseFirstSegment.length; i++) {
                polygonPointsClockwise.push(pointsClockwiseFirstSegment[i]);
                console.log(pointsClockwiseFirstSegment[i]);

            }
            for (let i = 0; i < pointsClockwiseSecondSegment.length; i++) {
                polygonPointsClockwise.push(pointsClockwiseSecondSegment[i]);
                console.log(pointsClockwiseSecondSegment[i]);
            }

            console.log(polygonPointsClockwise.length);

            let polygonPointsArray: number[] = [];
            for (let i = 0; i < polygonPointsClockwise.length; i++) {
                polygonPointsArray.push(polygonPointsClockwise[i].x);
                polygonPointsArray.push(polygonPointsClockwise[i].y);
            }

            console.log(polygonPointsClockwise.length);
            this.polygonNode = new Plexx.Polygon({points: polygonPointsArray, colour: this.colour});

            this.add(this.polygonNode);
            console.log("[PLEXX] " + this.toString() + " created");
        }

        public setColour(colour: string) {
            this.colourNode.setColour(colour);
        }

        public toString(): string {
            let text = this.getName() + " { ";
            for (let property in this) {
                if (this.hasOwnProperty(property)) text += property + ":" + " " + this[property] + ";";
            }
            text += "}";

            return text;
        }

    }

}
