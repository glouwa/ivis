namespace Plexx {

    /**
     * Possible string values of vertical text alignment parameter.
     */
    export type TextVertical = "bottom" | "middle" | "top";

    /**
     * Possible string values of horizontal text alignment parameter.
     */
    export type TextHorizontal = "left" | "center" | "right";

    /**
     * Interface representation of the Text node class.
     */
    export interface TextInterface extends TransformationsInterface {
        text: string;
        position: number[];
        colour?: string;
        fontSize?: number;
        fontFamily?: string;
        textVerticalAlignment?: TextVertical;
        textHorizontalAlignment?: TextHorizontal;
    }

    /**
     * The Text node draws a text with style and positioning options.
     */
    export class Text extends PrimitiveNode {
        private text: string;
        private position: Mathlib.Vec2;
        private colour: Colour;
        private fontSize: number;
        private fontFamily: string;
        private textVerticalAlignment: TextVertical;
        private textHorizontalAlignment: TextHorizontal;

        private textureCanvas: HTMLCanvasElement;
        private helperCanvas: HTMLCanvasElement;

        private offset: Mathlib.Vec2;


        /**
         * The Text node constructor.
         * @param textValues
         */
        constructor(textValues: TextInterface) {
            super("Text", textValues);

            this.text = textValues.text;
            this.position = textValues.position ? new Mathlib.Vec2(textValues.position[0], textValues.position[1]) : new Mathlib.Vec2(0, 0);
            this.colour = textValues.colour ? new Colour(textValues.colour) : new Colour("black");
            this.fontSize = textValues.fontSize || 14;
            this.fontFamily = textValues.fontFamily || "DejaVu Sans";
            this.textVerticalAlignment = textValues.textVerticalAlignment || "bottom";
            this.textHorizontalAlignment = textValues.textHorizontalAlignment || "left";

            this.helperCanvas = <HTMLCanvasElement> document.createElement("canvas");

            this.offset = this.calculateOffset();

            console.log("[PLEXX]", this.toString(), "created");
        }

        /**
         *
         * @returns {string}
         */
        public getText(): string {
            return this.text;
        }

        /**
         *
         * @param text
         */
        public setText(text: string) {
            this.text = text;
            this.offset = this.calculateOffset();
        }

        /**
         *
         * @returns {[number,number]}
         */
        public getPosition(): number[] {
            return [this.position.x, this.position.y];
        }

        /**
         *
         * @param position
         */
        public setPosition(position: number[]) {
            this.position = new Mathlib.Vec2(position[0], position[1]);
        }

        /**
         *
         * @returns {string}
         */
        public getColour(): string {
            return this.colour.getRGBAString();
        }

        /**
         *
         * @param colour
         */
        public setColour(colour: string) {
            this.colour = new Colour(colour);
        }

        /**
         *
         * @returns {number}
         */
        public getFontSize(): number {
            return this.fontSize;
        }

        /**
         *
         * @param fontSize
         */
        public setFontSize(fontSize: number) {
            this.fontSize = fontSize;

            this.offset = this.calculateOffset();
        }

        /**
         *
         * @returns {string}
         */
        public getFontFamily(): string {
            return this.fontFamily;
        }

        /**
         *
         * @param fontFamily
         */
        public setFontFamily(fontFamily: string) {
            this.fontFamily = fontFamily;

            this.offset = this.calculateOffset();
        }

        /**
         *
         * @returns {TextVertical}
         */
        public getTextVerticalAlignment(): TextVertical {
            return this.textVerticalAlignment;
        }

        /**
         *
         * @param textVerticalAlignment
         */
        public setTextVerticalAlignment(textVerticalAlignment: TextVertical) {
            this.textVerticalAlignment = textVerticalAlignment;

            this.offset = this.calculateOffset();
        }

        /**
         *
         * @returns {TextHorizontal}
         */
        public getTextHorizontalAlignment(): TextHorizontal {
            return this.textHorizontalAlignment;
        }

        /**
         *
         * @param textHorizontalAlignment
         */
        public setTextHorizontalAlignment(textHorizontalAlignment: TextHorizontal) {
            this.textHorizontalAlignment = textHorizontalAlignment;

            this.offset = this.calculateOffset();
        }

        /**
         * Returns a duplicate of the text node.
         * @returns {Plexx.Text}
         */
        public clone(): Text {
            return new Text({
                position: [this.position.x, this.position.y],
                text: this.text,
                colour: this.colour.getRGBAString(),
                fontSize: this.fontSize,
                fontFamily: this.fontFamily,
                textVerticalAlignment: this.textVerticalAlignment,
                textHorizontalAlignment: this.textHorizontalAlignment,
                translation: this.translation,
                scale: this.scale,
                scalePoint: this.scalePoint,
                rotation: this.rotation,
                rotationPoint: this.rotationPoint
            });
        }

        /**
         * Returns a string representation of the text node.
         * @returns {string}
         */
        public toString(): string {
            let text: string = "";

            text += this.getName() + " { ";
            text += "position: " + "[" + this.position.x + ", " + this.position.y + "]" + "; ";
            text += "text: \"" + this.text + "\"; ";
            text += "colour: \"" + this.colour.getCss3String() + "\"; ";
            text += "fontSize: " + this.fontSize + "; ";
            text += "fontFamily: \"" + this.fontFamily + "\"; ";
            text += "textVerticalAlignment: \"" + this.textVerticalAlignment + "\"; ";
            text += "textHorizontalAlignment: \"" + this.textHorizontalAlignment + "\"; ";
            text += "}";

            return text;
        }

        /**
         * Checks if the text node is represent at this position.
         * @param renderContext
         * @param position
         * @returns {boolean}
         */
        public hitBox(renderContext: RenderContext, position: Plexx.Mathlib.Vec2): boolean {
            let x: number = position.x;
            let y: number = position.y;
            let textWidth = this.getTextWidth();
            let textHeightBaseline = this.getTextHeight("Y", this.fontFamily, this.fontSize);
            let textHeightFull = this.getTextHeight("Yy", this.fontFamily, this.fontSize);
            let baselineOffset = textHeightFull - textHeightBaseline;

            return x >= (this.position.x + this.offset.x) && x <= (this.position.x + this.offset.x + textWidth) && y >= (this.position.y + this.offset.y - baselineOffset) && y <= (this.position.y + this.offset.y + textHeightBaseline);
        }

        /**
         * Returns a valid texture size.
         * @param size
         * @returns {number}
         */
        private static getValidTextureSize(size: number): number {
            let validSize = 2;

            while (size > validSize) {
                validSize *= 2;
            }

            return validSize;
        }

        /**
         * Generates the SVG object representing the text node.
         * @param renderContext
         * @param preTransformationMatrix
         * @returns {Plexx.XMLTag}
         */
        public generateSvg(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): XMLTag {
            let xmlTag = new XMLTag("text");
            let textWidth = this.getTextWidth();

            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let translate1 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, 1, 0, 0, -(this.position.y + this.offset.y), 1]);
            let mirrorMatrix2 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, 0, 1]);
            let translate2 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, 1, 0, 0, (this.position.y + this.offset.y), 1]);

            let tmp = (translate1.copy().multiply(mirrorMatrix2)).copy().multiply(translate2);
            let resultMatrix = (tmp.copy().multiply(preTransformationMatrix)).multiply(mirrorMatrix);

            xmlTag.addAttribute("x", String(this.position.x + this.offset.x));
            xmlTag.addAttribute("y", String(this.position.y + this.offset.y));
            xmlTag.addAttribute("transform", "matrix(" + resultMatrix.at(0) +
                " " + resultMatrix.at(1) +
                " " + resultMatrix.at(3) +
                " " + resultMatrix.at(4) +
                " " + resultMatrix.at(6) +
                " " + resultMatrix.at(7) +
                ")");

            xmlTag.addAttribute("fill", this.colour.getCss3String());
            xmlTag.addAttribute("textLength", String(textWidth));
            xmlTag.addAttribute("style", "font-family: " + this.fontFamily + ";" +
                "font-size: " + this.fontSize + ";"
            );

            xmlTag.setContent(this.text);

            return xmlTag;
        }

        /**
         * Updates and draw the text node on the HTML5 canvas.
         * @param renderContext
         * @param transformationMatrix
         * @returns {boolean}
         */
        public updateCanvas2d(renderContext: RenderContext, transformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let context = renderContext.getCanvas2dContext();
            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([
                1, 0, 0,
                0, -1, 0,
                0, renderContext.getHeight(), 1
            ]);
            let translate1 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, 1, 0, 0, -(this.position.y + this.offset.y), 1]);
            let mirrorMatrix2 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, 0, 1]);
            let translate2 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, 1, 0, 0, (this.position.y + this.offset.y), 1]);
            let tmp = (translate1.copy().multiply(mirrorMatrix2)).copy().multiply(translate2);
            let resultMatrix = (tmp.copy().multiply(transformationMatrix)).multiply(mirrorMatrix);

            context.save();
            context.setTransform(
                resultMatrix.at(0),
                resultMatrix.at(1),
                resultMatrix.at(3),
                resultMatrix.at(4),
                resultMatrix.at(6),
                resultMatrix.at(7)
            );
            context.fillStyle = this.colour.getCss3String();
            context.font = this.fontSize + "px" + " " + this.fontFamily;
            context.fillText(this.text, (this.position.x + this.offset.x), (this.position.y + this.offset.y));
            context.restore();

            return true;
        }

        /**
         * Updates and draw the text node on the WebGL canvas.
         * @param renderContext
         * @param transformationMatrix
         * @returns {boolean}
         */
        public updateWebGl(renderContext: RenderContext, transformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let gl: WebGLRenderingContext = renderContext.getWebGLRenderingContext();
            let canvasHeight: number = renderContext.getHeight();
            let canvasWidth: number = renderContext.getWidth();
            let n: number;

            // create new texture
            this.createCanvasTexture(transformationMatrix);

            // init shader
            gl.useProgram(this.shaderProgram);

            let tM = new Float32Array(transformationMatrix.all());
            let matrix = gl.getUniformLocation(this.shaderProgram, "matrix");
            gl.uniformMatrix3fv(matrix, false, tM);

            // set vertex information
            n = this.initVertexBuffers(gl, canvasWidth, canvasHeight, transformationMatrix);

            // set textures
            this.initTexture(gl, n);

            return true;
        }

        /**
         * Calculates the position offset based on the alignment values.
         * @returns {Plexx.Mathlib.Vec2}
         */
        private calculateOffset(): Mathlib.Vec2 {
            // TODO: the function used to get the width of the text should be mode independent (currently needs canvas context)
            // There is the function getComputedTextLength() for SVG elements, but for that the SVG element has to be already in the DOM tree
            // https://stackoverflow.com/questions/10254644/get-pixel-length-of-string-in-svg

            let offsetX: number = 0;
            let offsetY: number = 0;
            let textWidth: number;
            let textHeight: number;

            textWidth = this.getTextWidth();
            textHeight = this.fontSize;

            if (this.textHorizontalAlignment === "left") {
                offsetX = 0;
            } else if (this.textHorizontalAlignment === "center") {
                offsetX = -textWidth / 2;
            } else if (this.textHorizontalAlignment === "right") {
                offsetX = -textWidth;
            }

            if (this.textVerticalAlignment === "bottom") {
                offsetY = 0;
            } else if (this.textVerticalAlignment === "middle") {
                offsetY = -textHeight / 2;
            } else if (this.textVerticalAlignment === "top") {
                offsetY = -textHeight;
            }

            return new Mathlib.Vec2(offsetX, offsetY);
        }

        private getTextWidth() {
            let textWidth: number;

            textWidth = this.calculateTextWidth(this.text, this.fontFamily, this.fontSize);

            return textWidth;
        }

        /**
         * Returns the current width of the text based on the current font size and current font family.
         * @returns {number} Current width of the text.
         */
        private calculateTextWidth(text: string, fontFamily: string, fontSize: number): number {
            let textWidth: number;
            let helperContext: CanvasRenderingContext2D = this.helperCanvas.getContext("2d");

            helperContext.font = fontSize + "px" + " " + fontFamily;
            textWidth = helperContext.measureText(text).width;

            return textWidth;
        }

        /**
         * Returns the real height of the text if drawn on a canvas.
         * @param text
         * @param fontFamily
         * @param fontSize
         * @returns {number}
         */
        public getTextHeight(text: string, fontFamily: string, fontSize: number): number {
            let bufferData: any;
            let helperContext: CanvasRenderingContext2D = this.helperCanvas.getContext("2d");

            let canvasWidth = this.fontSize * 4;
            let canvasHeight = this.fontSize * 4;

            let textPositionX: number = canvasWidth / 2;
            let textPositionY: number = canvasHeight / 2;

            let topMarginFound: boolean = false;
            let bottomMarginFound: boolean = false;
            let topMargin = 0;
            let bottomMargin = canvasHeight;
            let x: number;
            let y: number;
            let height: number;

            this.helperCanvas.width = canvasWidth;
            this.helperCanvas.height = canvasHeight;

            helperContext.fillStyle = "#FFFFFFFF";
            helperContext.font = fontSize + "px" + " " + fontFamily;
            helperContext.fillText(text, textPositionX, textPositionY);

            bufferData = helperContext.getImageData(0, 0, canvasWidth, canvasHeight).data;

            y = canvasHeight;

            while (!bottomMarginFound) {
                for (x = 0; x < this.helperCanvas.width; x++) {
                    if (bufferData[(y * (this.helperCanvas.width * 4)) + (x * 4) + 3] > 0) {
                        bottomMargin = y;
                        bottomMarginFound = true;
                        break;
                    }
                }
                y--;
                if (y === 0) {
                    bottomMarginFound = true;
                    bottomMargin = 0;
                }
            }

            y = 0;

            while (!topMarginFound) {
                for (x = 0; (!topMarginFound && x < this.helperCanvas.width); x++) {
                    if (bufferData[(y * (this.helperCanvas.width * 4)) + (x * 4) + 3] > 0) {
                        topMargin = y;
                        topMarginFound = true;
                        break;
                    }
                }
                y++;
                if (y === this.helperCanvas.height) {
                    topMarginFound = true;
                    topMargin = this.helperCanvas.height;
                }
            }

            height = bottomMargin - topMargin;

            helperContext.clearRect(0, 0, canvasWidth, canvasHeight);

            return height;
        }

        /**
         *
         * @returns {BoundingBox2d}
         */
        public getBoundingBox(): BoundingBox2d {
            let min: Mathlib.Vec2 = new Mathlib.Vec2(0, 0);
            let max: Mathlib.Vec2 = new Mathlib.Vec2(0, 0);
            let boundingBox: BoundingBox2d;

            let tempCanvas = <HTMLCanvasElement> document.createElement("canvas");
            let tempContext: any = tempCanvas.getContext("2d");
            tempContext.font = this.fontSize + "px" + " " + this.fontFamily;
            let textWidth = tempContext.measureText(this.text).width;
            let textHeightBaseline = this.getTextHeight("Y", this.fontFamily, this.fontSize);
            let textHeightFull = this.getTextHeight("Yy", this.fontFamily, this.fontSize);
            let baselineOffset = textHeightFull - textHeightBaseline;

            min.x = this.position[0] + this.offset.x;
            min.y = this.position[1] + this.offset.y - baselineOffset;
            max.x = this.position[0] + this.offset.x + textWidth;
            max.y = this.position[1] + this.offset.y + textHeightBaseline;

            boundingBox = new BoundingBox2d(min, max);

            return boundingBox;
        }

        /**
         *
         * @param transformationMatrix
         */
        private createCanvasTexture(transformationMatrix: Mathlib.Mat3) {
            let textureCanvas: HTMLCanvasElement = <HTMLCanvasElement> document.createElement("canvas");
            let context: CanvasRenderingContext2D;
            let scaledTextWidth: number;
            let scale = Math.max(transformationMatrix.values[0], transformationMatrix.values[4]);
            let scaledFontSize = this.fontSize * scale;

            scaledTextWidth = this.calculateTextWidth(this.text, this.fontFamily, scaledFontSize) * 2;

            textureCanvas.width = Text.getValidTextureSize(scaledTextWidth) * 2;
            textureCanvas.height = Text.getValidTextureSize(scaledFontSize) * 2;

            context = textureCanvas.getContext("2d");

            context.font = scaledFontSize + "px" + " " + this.fontFamily;
            context.fillStyle = this.colour.getCss3String();
            context.fillText(this.text, 0, textureCanvas.height / 2);

            this.textureCanvas = textureCanvas;
        }

        /**
         *
         * @type {string}
         */
        private static VSHADER_SOURCE: string = `
            attribute vec4 a_Position;
            attribute vec2 a_TextureCoordinates;
            varying vec2 v_TextureCoordinates;
            uniform vec2 u_Resolution;
            uniform mat3 matrix;

            void main() {
              vec2 tmp1 = (matrix * vec3(a_Position.x, a_Position.y, 1)).xy / u_Resolution;
              vec2 tmp2 = tmp1 * 2.0;
              vec2 tmp3 = tmp2 - 1.0;
              gl_Position = vec4(tmp3 , a_Position.z, a_Position.w);
              v_TextureCoordinates = a_TextureCoordinates;
            }
            `;

        /**
         *
         * @type {string}
         */
        private static FSHADER_SOURCE: string = `
            precision mediump float;
            uniform sampler2D u_Sampler;
            varying vec2 v_TextureCoordinates;

            void main() {
              gl_FragColor = texture2D(u_Sampler, v_TextureCoordinates);
            }
            `;

        /**
         *
         * @param gl
         * @param canvasWidth
         * @param canvasHeight
         * @param transformationMatrix
         * @returns {number}
         */
        private initVertexBuffers(gl: WebGLRenderingContext, canvasWidth: number, canvasHeight: number, transformationMatrix: Plexx.Mathlib.Mat3): number {
            let scale = Math.max(transformationMatrix.values[0], transformationMatrix.values[4]);
            let height: number = this.textureCanvas.height / scale;
            let width: number = this.textureCanvas.width / scale;

            // console.log("init", height, width);
            let x = this.position.x + this.offset.x;
            let y = this.position.y + this.offset.y - height / 2;
            let verticesTextureCoordinates = new Float32Array([
                x, y + height, 0.0, 1.0,
                x, y, 0.0, 0.0,
                x + width, y + height, 1.0, 1.0,
                x + width, y, 1.0, 0.0,
            ]);
            let n = 4; // number of vertices

            // bind buffer object to target
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, verticesTextureCoordinates, gl.STATIC_DRAW);

            let FSIZE = verticesTextureCoordinates.BYTES_PER_ELEMENT;

            let u_Resolution = gl.getUniformLocation(this.shaderProgram, "u_Resolution");
            gl.uniform2f(u_Resolution, canvasWidth, canvasHeight);

            let a_Position = gl.getAttribLocation(this.shaderProgram, "a_Position");

            gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, FSIZE * 4, 0);
            gl.enableVertexAttribArray(a_Position);

            let a_TextureCoordinates = gl.getAttribLocation(this.shaderProgram, "a_TextureCoordinates");

            gl.vertexAttribPointer(a_TextureCoordinates, 2, gl.FLOAT, false, FSIZE * 4, FSIZE * 2);
            gl.enableVertexAttribArray(a_TextureCoordinates);


            return n;
        }

        /**
         *
         * @param gl
         * @param n
         */
        private initTexture(gl: WebGLRenderingContext, n: number) {
            let canvasTexture: WebGLTexture = gl.createTexture();
            let u_Sampler = gl.getUniformLocation(this.shaderProgram, "u_Sampler");
            this.loadTexture(gl, n, canvasTexture, u_Sampler);
        }

        /**
         *
         * @param gl
         * @param n
         * @param texture
         * @param u_Sampler
         */
        private loadTexture(gl: WebGLRenderingContext, n: number, texture: WebGLTexture, u_Sampler: any) {
            // flip the image's y axis
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);

            // bind the texture object to the target
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.textureCanvas);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

            // Set the texture unit 0 to the sampler
            gl.uniform1i(u_Sampler, 0);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, n);
        }

        /**
         * Initializes WebGL shader and WebGL program.
         * @param renderContext
         */
        public initWebGlShader(renderContext: RenderContext) {
            let gl = <WebGLRenderingContext> renderContext.getCanvasWebGL().getContext("webgl");
            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

            this.shaderProgram = gl.createProgram();

            gl.shaderSource(vertexShader, Text.VSHADER_SOURCE);
            gl.compileShader(vertexShader);

            gl.shaderSource(fragmentShader, Text.FSHADER_SOURCE);
            gl.compileShader(fragmentShader);

            gl.attachShader(this.shaderProgram, vertexShader);
            gl.attachShader(this.shaderProgram, fragmentShader);
            gl.linkProgram(this.shaderProgram);
        }
    }
}
