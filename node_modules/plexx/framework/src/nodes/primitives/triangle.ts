/// <reference path="../../helper/references.ts" />

namespace Plexx {

    export interface TriangleInterface extends Plexx.TransformationsInterface {
        positionA: number[];
        positionB: number[];
        positionC: number[];
        colour?: string;
    }

    export class Triangle extends Plexx.PrimitiveNode {
        positionA: number[];
        positionB: number[];
        positionC: number[];
        private colourNode: Colour;
        colour: string;

        constructor(values: TriangleInterface) {
            super("Triangle", values);

            this.positionA = values.positionA;
            this.positionB = values.positionB;
            this.positionC = values.positionC;
            this.colour = values.colour || "black";
            this.colourNode = new Colour(values.colour);

            console.log("CREATE " + this.toString());
        }

        public clone(): Triangle {
            return new Triangle({
                positionA: this.positionA,
                positionB: this.positionB,
                positionC: this.positionC,
                colour: this.colour,
                translation: this.translation,
                scale: this.scale,
                scalePoint: this.scalePoint,
                rotation: this.rotation,
                rotationPoint: this.rotationPoint
            });
        }

        public setColour(colour: string) {
            this.colourNode.setColour(colour);
        }

        public toString() {
            let triangleString = this.getName() + " { ";
            triangleString += "positionA: " + this.positionA + "; "
            triangleString += "positionB: " + this.positionB + "; "
            triangleString += "positionC: " + this.positionC + "; "
            triangleString += "colour: " + this.colour + "; "
            triangleString += "translation: " + this.translation + "; "
            triangleString += "translation: " + this.translation + "; "
            triangleString += "scale: " + this.scale + "; "
            triangleString += "rotation: " + this.rotation + "; "
            triangleString += "}";
            return triangleString;
        }

        public hitBox(renderContext: RenderContext, position: Plexx.Mathlib.Vec2): boolean {
            let x: number = position.x;
            let y: number = position.y;
            let a: Plexx.Mathlib.Mat3;
            let b: Plexx.Mathlib.Mat3;
            let c: Plexx.Mathlib.Mat3;

            a = new Plexx.Mathlib.Mat3([1, this.positionA[0], this.positionA[1], 1, this.positionB[0], this.positionB[1], 1, x, y]);
            b = new Plexx.Mathlib.Mat3([1, this.positionB[0], this.positionB[1], 1, this.positionC[0], this.positionC[1], 1, x, y]);
            c = new Plexx.Mathlib.Mat3([1, this.positionC[0], this.positionC[1], 1, this.positionA[0], this.positionA[1], 1, x, y]);

            return (a.det() <= 0 && b.det() <= 0 && c.det() <= 0);
        }

        public getBoundingBox(): BoundingBox2d {
            let pointsX: number[] = [];
            let pointsY: number[] = [];
            pointsX.push(this.positionA[0]);
            pointsX.push(this.positionB[0]);
            pointsX.push(this.positionC[0]);
            pointsY.push(this.positionA[1]);
            pointsY.push(this.positionB[1]);
            pointsY.push(this.positionC[1]);

            return new BoundingBox2d(new Mathlib.Vec2(pointsX[0], pointsY[0]), new Mathlib.Vec2(pointsX[2], pointsY[2]));
        }

        public generateSvg(renderContext: RenderContext, transformationMatrix: Plexx.Mathlib.Mat3): XMLTag {
            let xmlTag = new XMLTag("polygon");
            let points: string;

            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = transformationMatrix.copy().multiply(mirrorMatrix);

            points = this.positionA[0] + "," + this.positionA[1];
            points += " " + this.positionB[0] + "," + this.positionB[1];
            points += " " + this.positionC[0] + "," + this.positionC[1];

            xmlTag.addAttribute("points", points);
            xmlTag.addAttribute("fill", this.colourNode.getCss3String());
            xmlTag.addAttribute("transform", "matrix(" + resultMatrix.at(0) + " " + resultMatrix.at(1) + " " + resultMatrix.at(3) + " " + resultMatrix.at(4) + " " + resultMatrix.at(6) + " " + resultMatrix.at(7) + ")");
            xmlTag.addAttribute("stroke", "none");

            return xmlTag;
        }

        public updateCanvas2d(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let context = renderContext.getCanvas2D().getContext("2d");
            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = preTransformationMatrix.copy().multiply(mirrorMatrix);

            context.save();
            context.beginPath();
            context.setTransform(resultMatrix.at(0), resultMatrix.at(1), resultMatrix.at(3), resultMatrix.at(4), resultMatrix.at(6), resultMatrix.at(7));
            context.moveTo(this.positionA[0], this.positionA[1]);
            context.lineTo(this.positionB[0], this.positionB[1]);
            context.lineTo(this.positionC[0], this.positionC[1]);
            context.fillStyle = this.colourNode.getCss3String();
            context.strokeStyle = "none";
            context.fill();
            context.closePath();
            context.restore();

            return true;
        }

        public updateWebGl(renderContext: RenderContext, transformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let gl: WebGLRenderingContext = renderContext.getWebGLRenderingContext();

            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, Triangle.vertexShaderSource);
            gl.compileShader(vertexShader);

            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, Triangle.fragmentShaderSource);
            gl.compileShader(fragmentShader);

            let shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);
            gl.useProgram(shaderProgram);
            let positionLocation = gl.getAttribLocation(shaderProgram, "aVertexPosition");

            let buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            let resolutionLocation = gl.getUniformLocation(shaderProgram, "resolution");
            // console.log(resolutionLocation);
            gl.uniform2f(resolutionLocation, renderContext.getCanvasWebGL().getAttribute("width"), renderContext.getCanvasWebGL().getAttribute("height"));

            let tM = new Float32Array(transformationMatrix.all());
            let matrix = gl.getUniformLocation(shaderProgram, "matrix");
            gl.uniformMatrix3fv(matrix, false, tM);

            let colourValues = gl.getUniformLocation(shaderProgram, "colour");
            gl.uniform4f(colourValues, this.colourNode.getR(), this.colourNode.getG(), this.colourNode.getB(), this.colourNode.getA());


            let polygonVertices = new Float32Array(6);
            polygonVertices[0] = this.positionA[0];
            polygonVertices[1] = this.positionA[1];
            polygonVertices[2] = this.positionB[0];
            polygonVertices[3] = this.positionB[1];
            polygonVertices[4] = this.positionC[0];
            polygonVertices[5] = this.positionC[1];

            gl.bufferData(gl.ARRAY_BUFFER, polygonVertices, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 3);

            return true;
        }

    }

}
