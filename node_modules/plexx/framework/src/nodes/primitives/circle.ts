namespace Plexx {

    export interface CircleInterface extends Plexx.TransformationsInterface {
        radius: number;
        position: number[];
        colour?: string;
        borderColour?: string;
        borderWidth?: number;
    }

    export class Circle extends Plexx.PrimitiveNode implements CircleInterface {

        public radius: number;
        public position: number[];
        public colour: string;

        public borderColour: string;
        public borderWidth: number;


        private static CIRCLE_SIDES: number = 120;

        private colourNode: Colour;
        private borderColourNode: Plexx.Colour;


        constructor(values: CircleInterface) {
            super("Circle", values);

            this.radius = values.radius;
            this.position = values.position;
            this.colour = values.colour;
            this.borderColour = values.borderColour || values.colour;
            this.borderWidth = values.borderWidth || 0;

            this.colourNode = new Colour(this.colour);
            this.borderColourNode = new Colour(this.borderColour);

            console.log("[PLEXX] " + this.toString() + " created");
        }

        public toString() {
            let circleString = this.getName() + " { ";

            circleString += "radius: " + this.radius + "; ";
            circleString += "position: " + this.position + "; ";
            circleString += "colour: " + this.colour + "; ";
            circleString += "borderColour: " + this.borderColour + "; ";
            circleString += "borderWidth: " + this.borderWidth + "; ";
            circleString += "}";

            return circleString;
        }

        public setColour(colour: string) {
            this.colourNode.setColour(colour);
        }

        public hitBox(renderContext: RenderContext, position: Plexx.Mathlib.Vec2): boolean {
            let x: number = position.x;
            let y: number = position.y;

            if (Math.pow((x - this.position[0]), 2) + Math.pow((y - this.position[1]), 2) < Math.pow(this.radius, 2)) {
                return true;
            }
            else return false;
        }

        public boundingBox(renderContext: RenderContext, position: Plexx.Mathlib.Vec2): boolean {
            let x: number = position.x;
            let y: number = position.y;

            if (Math.pow((x - this.position[0]), 2) + Math.pow((y - this.position[1]), 2) < Math.pow(this.radius, 2)) {
                return true;
            }
            else return false;
        }

        public updateCanvas2d(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let context = renderContext.getCanvas2D().getContext("2d");

            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = preTransformationMatrix.copy().multiply(mirrorMatrix);

            context.save();
            context.beginPath();
            context.setTransform(resultMatrix.at(0), resultMatrix.at(1), resultMatrix.at(3), resultMatrix.at(4), resultMatrix.at(6), resultMatrix.at(7));
            context.arc(this.position[0], this.position[1], this.radius, 0, 2 * Math.PI, false);
            context.fillStyle = this.colourNode.getCss3String();
            context.fill();
            if (this.borderWidth !== 0) {
                // console.log(this.borderWidth);
                context.strokeStyle = this.borderColourNode.getCss3String();
                context.lineWidth = this.borderWidth;
                context.stroke();
            }
            context.closePath();
            context.restore();

            return true;
        }

        public generateSvg(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): Plexx.XMLTag {
            let xmlTag = new XMLTag("circle");

            let svgElement = document.createElementNS(Constants.SVG_NAMESPACE, "circle");


            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = preTransformationMatrix.copy().multiply(mirrorMatrix);

            xmlTag.addAttribute("cx", String(this.position[0]));
            xmlTag.addAttribute("cy", String(this.position[1]));
            xmlTag.addAttribute("transform", "matrix(" + resultMatrix.at(0) +
                " " + resultMatrix.at(1) +
                " " + resultMatrix.at(3) +
                " " + resultMatrix.at(4) +
                " " + resultMatrix.at(6) +
                " " + resultMatrix.at(7) +
                ")");
            xmlTag.addAttribute("r", String(this.radius));
            xmlTag.addAttribute("fill", String(this.colourNode.getCss3String()));
            xmlTag.addAttribute("stroke", "none");

            console.log(xmlTag.generateSvgText());
            return xmlTag;
        }

        public updateWebGl(renderContext: RenderContext, transformationMatrix: Plexx.Mathlib.Mat3): boolean {
            // console.log("update webgl");
            let gl: WebGLRenderingContext = renderContext.getWebGLRenderingContext();

            // if (this.shaderProgram == null) {
            //     console.log("shader program NULL");
            // }
            gl.useProgram(this.shaderProgram);

            this.shaderProgram.resolutionLocation = gl.getUniformLocation(this.shaderProgram, "resolution");
            this.shaderProgram.matrix = gl.getUniformLocation(this.shaderProgram, "matrix");
            this.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
            this.shaderProgram.colourValues = gl.getUniformLocation(this.shaderProgram, "colour");

            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.uniform2f(this.shaderProgram.resolutionLocation, renderContext.getCanvasWebGL().getAttribute("width"), renderContext.getCanvasWebGL().getAttribute("height"));

            let tM = new Float32Array(transformationMatrix.all());
            gl.uniformMatrix3fv(this.shaderProgram.matrix, false, tM);

            gl.uniform4f(this.shaderProgram.colourValues, this.colourNode.getR(), this.colourNode.getG(), this.colourNode.getB(), this.colourNode.getA());

            let polygonVertices = new Float32Array(2 * (Circle.CIRCLE_SIDES));
            let canvasHeight = renderContext.getHeight();

            for (let i = 0; i < Circle.CIRCLE_SIDES; i++) {
                polygonVertices[2 * i] = this.radius * Math.cos(2 * Math.PI / Circle.CIRCLE_SIDES * i) + this.position[0];
                polygonVertices[(2 * i) + 1] = this.radius * Math.sin(2 * Math.PI / Circle.CIRCLE_SIDES * i) + this.position[1];
            }

            gl.bufferData(gl.ARRAY_BUFFER, polygonVertices, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);
            gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLE_FAN, 0, Circle.CIRCLE_SIDES);

            return true;
        }

        public clone(): Circle {
            return null;
        }
    }

}
