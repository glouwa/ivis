/// <reference path="../../helper/references.ts" />

namespace Plexx {
    export interface LineInterface extends Plexx.TransformationsInterface {
        points: number[];
        width: number;
        type: Constants.LineType;
        colour: string;
        startArrow: boolean;
        endArrow: boolean;
        arrowScale: number;
    }

    export class Line extends Plexx.Group implements LineInterface {
        public points: number[];
        public width: number;
        public type: Constants.LineType;
        public colour: string;
        private colourNode: Colour;
        public startArrow: boolean;
        public endArrow: boolean;
        public arrowScale: number;

        private static startArrowDefault: boolean = false;
        private static endArrowDefault: boolean = false;
        private static arrowScaleDefault: number = 10;

        private startArrowNode: Plexx.Triangle;
        private endArrowNode: Plexx.Triangle;
        private lineNode: Plexx.Rectangle;

        constructor(values: LineInterface) {
            super({name: "Line"});

            this.points = values.points;
            this.width = values.width || Constants.DEFAULT_HEIGHT;
            this.type = values.type || Constants.LineType.Default;
            this.colour = values.colour;
            this.colourNode = new Colour(values.colour);
            this.startArrow = values.startArrow || Line.startArrowDefault;
            this.endArrow = values.endArrow || Line.endArrowDefault;
            this.arrowScale = values.arrowScale || Line.arrowScaleDefault;

            let lineStartPosX: number = 0;
            let lineStartPosY: number = -this.width / 2;
            let x1: number = this.points[0];
            let y1: number = this.points[1];
            let x2: number = this.points[2];
            let y2: number = this.points[3];
            let length: number = Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
            let lineLength: number = length;

            this.setRotation(Math.atan2(y2 - y1, x2 - x1) / Math.PI * 180, [0, 0]);
            this.setTranslation([x1, y1]);
            console.log(this.rotation);

            if (this.startArrow) {
                this.startArrowNode = new Plexx.Triangle({
                    positionA: [0, 0],
                    positionB: [5 * this.arrowScale, this.width / 2 + this.arrowScale],
                    positionC: [5 * this.arrowScale, -this.width / 2 - this.arrowScale],
                    colour: this.colour
                });
                lineLength -= 5 * this.arrowScale;
                lineStartPosX = 5 * this.arrowScale;
                this.add(this.startArrowNode);
            }

            if (this.endArrow) {
                this.endArrowNode = new Plexx.Triangle({
                    positionA: [length, 0],
                    positionB: [length - 5 * this.arrowScale, this.width / 2 + this.arrowScale],
                    positionC: [length - 5 * this.arrowScale, -this.width / 2 - this.arrowScale],
                    colour: this.colour
                });
                lineLength -= 5 * this.arrowScale;
                this.add(this.endArrowNode);
            }

            this.lineNode = new Plexx.Rectangle({
                width: lineLength,
                height: this.width,
                position: [lineStartPosX, lineStartPosY],
                colour: this.colour
            });
            console.log("Line", lineStartPosX, lineStartPosY);

            this.add(this.lineNode);
        }

        public setColour(colour: string) {
            this.colourNode.setColour(colour);
            if (this.startArrowNode) this.startArrowNode.setColour(colour);
            if (this.endArrowNode) this.endArrowNode.setColour(colour);
            this.lineNode.setColour(colour);
        }

        public setPoints(points: number[]) {
            this.points[0] = points[0];
            this.points[1] = points[1];
            this.points[2] = points[2];
            this.points[3] = points[3];
            let lineStartPosX: number = 0;
            let lineStartPosY: number = -this.width / 2;
            let x1: number = points[0];
            let y1: number = points[1];
            let x2: number = points[2];
            let y2: number = points[3];
            let length: number = Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
            let lineLength: number = length;

            this.setRotation(Math.atan2(y2 - y1, x2 - x1) / Math.PI * 180, [x1, y1]);
            this.setTranslation([x1, y1]);

            if (this.startArrow) {
                this.startArrowNode.positionA = [0, 0];
                this.startArrowNode.positionB = [5 * this.arrowScale, this.width / 2 + 2 * this.arrowScale];
                this.startArrowNode.positionC = [5 * this.arrowScale, -this.width / 2 - 2 * this.arrowScale];
                lineLength -= 5 * this.arrowScale;
                lineStartPosX = 5 * this.arrowScale;
            }

            if (this.endArrow) {
                this.endArrowNode.positionA = [length, 0];
                this.endArrowNode.positionB = [length - 5 * this.arrowScale, this.width / 2 + 2 * this.arrowScale];
                this.endArrowNode.positionC = [length - 5 * this.arrowScale, -this.width / 2 - 2 * this.arrowScale];
                lineLength -= 5 * this.arrowScale;
            }

            this.lineNode.width = lineLength;
            this.lineNode.height = this.width;
            this.lineNode.position = new Plexx.Mathlib.Vec2(lineStartPosX, lineStartPosY);
        }
    }
}
