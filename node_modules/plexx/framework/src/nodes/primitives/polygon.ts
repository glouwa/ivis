/// <reference path="../../helper/references.ts" />

namespace Plexx {

    export interface PolygonInterface extends Plexx.TransformationsInterface {
        points: number[];
        colour: string;
    }

    export class Polygon extends Plexx.PrimitiveNode {
        private points: number[];
        private colour: string;
        private colourNode: Colour;

        constructor(values: PolygonInterface) {
            super("Polygon", values);
            this.points = values.points;
            this.colour = values.colour;
            this.colourNode = new Colour(this.colour);
            console.log("[FDGL] " + this.toString() + " created");
        }

        public clone(): Polygon {
            return new Polygon({
                points: this.points,
                colour: this.colour
            });
        }

        public setColour(colour: string) {
            this.colourNode.setColour(colour);
        }

        public toString() {
            let polygonString: string = this.getName() + " { ";

            polygonString += "position: ";
            for (let index: number = 0; index < this.points.length / 2; index++) {
                if (index === 0) {
                    polygonString += "(" + this.points[2 * index] + ", " + this.points[2 * index + 1] + ")";
                }
                else {
                    polygonString += ", (" + this.points[2 * index] + ", " + this.points[2 * index + 1] + ")";
                }
            }
            polygonString += "}";

            return polygonString;
        }

        public hitBox(renderContext: RenderContext, position: Plexx.Mathlib.Vec2): boolean {
            let tempCanvas = <HTMLCanvasElement> document.createElement("canvas");
            let tempContext: any = tempCanvas.getContext("2d");
            let x: number = position.x;
            let y: number = position.y;
            let isPointInsidePath: boolean;

            tempContext.save();
            tempContext.beginPath();
            tempContext.lineTo(this.points[0], this.points[1]);
            for (let i = 1; i < this.points.length / 2; i++) {
                tempContext.lineTo(this.points[2 * i], this.points[2 * i + 1]);
            }
            tempContext.fillStyle = this.colourNode.getCss3String();
            tempContext.fill();
            tempContext.strokeStyle = "none";
            tempContext.lineWidth = 0;
            tempContext.closePath();

            isPointInsidePath = tempContext.isPointInPath(x, y);
            tempContext.restore();

            return isPointInsidePath;
        }

        public updateCanvas2d(renderContext: RenderContext, transformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let context = renderContext.getCanvas2D().getContext("2d");
            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = transformationMatrix.copy().multiply(mirrorMatrix);

            context.save();
            context.beginPath();
            context.setTransform(resultMatrix.at(0), resultMatrix.at(1), resultMatrix.at(3), resultMatrix.at(4), resultMatrix.at(6), resultMatrix.at(7));
            context.moveTo(this.points[0], this.points[1]);
            for (let i = 1; i < this.points.length / 2; i++) {
                context.lineTo(this.points[2 * i], this.points[2 * i + 1]);
            }
            context.fillStyle = this.colourNode.getCss3String();
            context.fill();
            context.strokeStyle = "none";
            context.lineWidth = 0;
            context.closePath();
            context.restore();

            return true;
        }

        public generateSvg(renderContext: RenderContext, transformationMatrix: Plexx.Mathlib.Mat3): XMLTag {
            let xmlTag = new XMLTag("path");
            let points: string = "";

            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = transformationMatrix.copy().multiply(mirrorMatrix);

            points = this.points[0] + "," + this.points[1];
            for (let i = 1; i < this.points.length / 2; i++) {
                points += " " + this.points[2 * i] + "," + this.points[2 * i + 1];
            }
            xmlTag.addAttribute("d", "M " + points + " z");
            xmlTag.addAttribute("transform", "matrix(" + resultMatrix.at(0) + " " + resultMatrix.at(1) + " " + resultMatrix.at(3) + " " + resultMatrix.at(4) + " " + resultMatrix.at(6) + " " + resultMatrix.at(7) + ")");
            xmlTag.addAttribute("fill", this.colourNode.getCss3String());

            return xmlTag;
        }


        public updateWebGl(renderContext: RenderContext, transformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let gl = <WebGLRenderingContext> renderContext.getCanvasWebGL().getContext("webgl", {stencil: true});
            gl.useProgram(this.shaderProgram);

            let positionLocation = gl.getAttribLocation(this.shaderProgram, "aVertexPosition");

            let matrixValues = new Float32Array(transformationMatrix.all());
            let matrix = gl.getUniformLocation(this.shaderProgram, "matrix");
            gl.uniformMatrix3fv(matrix, false, matrixValues);

            let colourValues = gl.getUniformLocation(this.shaderProgram, "colour");
            gl.uniform4f(colourValues, this.colourNode.getR(), this.colourNode.getG(), this.colourNode.getB(), this.colourNode.getA());

            let buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            let resolutionLocation = gl.getUniformLocation(this.shaderProgram, "resolution");
            gl.uniform2f(resolutionLocation, renderContext.getCanvasWebGL().getAttribute("width"), renderContext.getCanvasWebGL().getAttribute("height"));

            gl.clearStencil(0x0);
            gl.enable(gl.STENCIL_TEST);

            // 1. clear the stencil buffer
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.STENCIL_BUFFER_BIT);

            // 2. disable writing into the color buffer
            gl.colorMask(false, false, false, false);

            // 3. draw each of the triangles in turn, using the GL_INVERT function in the stencil buffer
            let numberOfPoints = this.points.length / 2;

            gl.stencilOp(gl.INVERT, gl.INVERT, gl.INVERT);
            gl.stencilFunc(gl.ALWAYS, 1, 0);

            for (let i = 1; i <= numberOfPoints - 2; i++) {
                let polygonVertices = new Float32Array(this.points.length);
                polygonVertices[0] = this.points[0];
                polygonVertices[1] = this.points[1];
                polygonVertices[2] = this.points[i * 2];
                polygonVertices[3] = this.points[i * 2 + 1];
                polygonVertices[4] = this.points[i * 2 + 2];
                polygonVertices[5] = this.points[i * 2 + 3];

                let stencilStepBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, stencilStepBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, polygonVertices, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

                // use TRIANGLE_FAN for best performance
                gl.drawArrays(gl.TRIANGLE_FAN, 0, 3);

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                gl.deleteBuffer(stencilStepBuffer);
            }

            // 4. draw a large polygon over the whole region, but allow drawing only where the stencil buffer is nonzero

            gl.colorMask(true, true, true, true);

            // only draw against non-zero values
            gl.stencilFunc(gl.EQUAL, 1, 1);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

            let xValues: number[] = [];
            let yValues: number[] = [];

            let xIndex = 0;
            let yIndex = 0;
            for (let i = 0; i < this.points.length; i++) {
                if (i % 2 === 0) {
                    xValues[xIndex] = this.points[i];
                    xIndex++;
                }
                else {
                    yValues[yIndex] = this.points[i];
                    yIndex++;
                }
            }

            let minX = Math.min.apply(Mathlib, xValues);
            let minY = Math.min.apply(Mathlib, yValues);
            let maxX = Math.max.apply(Mathlib, xValues);
            let maxY = Math.max.apply(Mathlib, yValues);

            let polygonVertices = new Float32Array(8);

            polygonVertices[0] = minX;
            polygonVertices[1] = minY;

            polygonVertices[2] = minX;
            polygonVertices[3] = maxY;

            polygonVertices[4] = maxX;
            polygonVertices[5] = maxY;

            polygonVertices[6] = maxX;
            polygonVertices[7] = minY;

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, polygonVertices, gl.STATIC_DRAW);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.deleteBuffer(buffer);

            // cleanup
            gl.clearColor(1, 1, 1, 1);
            gl.clearStencil(gl.STENCIL_BUFFER_BIT);
            gl.disable(gl.STENCIL_TEST);

            return true;
        }
    }
}
