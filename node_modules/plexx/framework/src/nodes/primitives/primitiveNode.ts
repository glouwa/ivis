/// <reference path="../../helper/references.ts" />

namespace Plexx {
    export interface PrimitiveNodeinterface {
        translationNode: TranslationNode;
        rotationNode: RotationNode;
        scaleNode: ScaleNode;

        updateCanvas2d(renderContext: RenderContext, currentTransformationMatrix: Mathlib.Mat3): boolean;
        updateWebGl(renderContext: RenderContext, currentTransformationMatrix: Mathlib.Mat3): boolean;
        generateSvg(renderContext: RenderContext, currentTransformationMatrix: Mathlib.Mat3): XMLTag;
        initWebGlShader(renderContext: RenderContext): any;
        initWebGlBuffers(renderContext: RenderContext): any;
        initWebGlTextures(renderContext: RenderContext): any;
        getBoundingBox(): BoundingBox2d;

        toString(): string;
        clone(): PrimitiveNode;
        hitBox(renderContext: RenderContext, position: Mathlib.Vec2): boolean;
        executeClickEvent(): void;
        on(mouseEventName: string, callback: (object: any) => {}): any;
        eventMap: {[eventName: string]: (event: any) => void; };
        setTranslation(translation: number[]);
        mouseOver: boolean;
        mouseOverExecuted: boolean;
        translation: number[];

        isHidden: boolean;
        draggable: boolean;
        isDragging: boolean;
        draggingPoint: Mathlib.Vec2;
        draggingSpace: number[];
    }

    export type callback = (data: string) => void;

    export interface TransformationsInterface {
        translation?: number[];
        scale?: number[];
        scalePoint?: number[];
        rotation?: number;
        rotationPoint?: number[];
        draggable?: boolean;
        draggingSpace?: number[];
    }

    export class PrimitiveNode extends SceneGraphNode implements PrimitiveNodeinterface {
        translationNode: TranslationNode;
        rotationNode: RotationNode;
        scaleNode: ScaleNode;
        public draggable: boolean = false;
        public isDragging: boolean = false;
        public draggingPoint: Mathlib.Vec2;

        translation: number[];
        scale: number[];
        scalePoint: number[];
        rotation: number;
        rotationPoint: number[];
        eventMap: {[eventName: string]: (event: any) => void; };
        mouseOver: boolean;
        mouseOverExecuted: boolean;

        isHidden: boolean;
        draggingSpace: number[];

        protected shaderProgram: any;
        protected buffer: any;
        protected texture: any;

        protected static vertexShaderSource: string =
            "attribute vec2 aVertexPosition;                                                                       \n" +
            "                                                                                                      \n" +
            "uniform int matrix_size;                                                                              \n" +
            "uniform mat3 matrix;                                                                                  \n" +
            "uniform vec2 resolution;                                                                              \n" +
            "                                                                                                      \n" +
            "void main() {                                                                                         \n" +
            "  vec2 pos = (matrix * vec3(aVertexPosition, 1)).xy;                                                  \n" +
            "  vec2 tmp1 = pos / (resolution);                                                                     \n" +
            "  vec2 tmp2 = tmp1 * 2.0;                                                                             \n" +
            "  vec2 tmp3 = tmp2 - 1.0;                                                                             \n" +
            "  gl_Position = vec4(tmp3 , 0, 1);                                                                    \n" +
            "}                                                                                                     \n";

        protected static fragmentShaderSource: string =
            "precision mediump float;                                                                              \n" +
            "                                                                                                      \n" +
            "uniform vec4 colour;                                                                                  \n" +
            "                                                                                                      \n" +
            "void main() {                                                                                         \n" +
            "  gl_FragColor = colour;                                                                              \n" +
            "}                                                                                                     \n";

        constructor(name: string, values: TransformationsInterface) {
            super(name);
            this.translation = values.translation || [0, 0];
            this.scale = values.scale || [1, 1];
            this.scalePoint = values.scalePoint || [0, 0];
            this.rotation = values.rotation || 0;
            this.rotationPoint = values.rotationPoint || [0, 0];

            this.translationNode = new TranslationNode(values);
            this.scaleNode = new ScaleNode(values);
            this.rotationNode = new RotationNode(values);
            this.eventMap = {};
            this.mouseOver = false;
            this.isHidden = false;
            this.draggable = values.draggable;
            this.draggingSpace = values.draggingSpace || [];

        }

        public on(eventName: string, callback: (event: any) => void) {
            this.eventMap[eventName] = callback;
        }

        public setTranslation(translation: number[]) {
            this.translation = translation;
            this.translationNode.translation = translation;
        }

        public addTranslation(translation: number[]) {
            this.translation[0] += translation[0];
            this.translation[1] += translation[1];
            this.translationNode.translation[0] += translation[0];
            this.translationNode.translation[1] += translation[1];
        }

        public setRotation(rotation: number) {
            this.rotation = rotation;
            this.rotationNode.rotation = rotation;
        }

        public addRotation(rotation: number) {
            this.rotation += rotation;
            this.rotationNode.rotation += rotation;
        }

        public setScale(scale: number[]) {
            this.scale = scale;
            this.scaleNode.scale = scale;
        }

        public addScale(scale: number[]) {
            this.scale[0] += scale[0];
            this.scale[1] += scale[1];
            this.scaleNode.scale[0] += scale[0];
            this.scaleNode.scale[1] += scale[1];
        }

        public accept(nodeVisitor: NodeVisitorInterface): any {
            return nodeVisitor.visitPrimitiveNode(this);
        }

        public updateWebGl(renderContext: RenderContext, currentTransformationMatrix: Mathlib.Mat3): boolean {
            return false;
        }

        public updateCanvas2d(renderContext: RenderContext, currentTransformationMatrix: Mathlib.Mat3): boolean {
            return false;
        }

        public generateSvg(renderContext: RenderContext, preTransformationMatrix: Mathlib.Mat3): XMLTag {
            let xmlTag: XMLTag = new XMLTag("primitiveNode");
            return xmlTag;
        }

        public clone(): PrimitiveNode {
            return null;
        }

        public hitBox(renderContext: RenderContext, mousePosition: Mathlib.Vec2) {
            return false;
        }

        public getBoundingBox(): BoundingBox2d {
            return null;
        }

        public executeClickEvent() {
            console.log("YEAH I WAS CLICKED!");
        }

        public getTransformationInterface(): TransformationsInterface {
            return {
                translation: this.translation,
                scale: this.scale,
                scalePoint: this.scalePoint,
                rotation: this.rotation,
                rotationPoint: this.rotationPoint
            };

        }

        public initWebGlShader(renderContext: RenderContext) {
            let gl = <WebGLRenderingContext> renderContext.getWebGLRenderingContext();
            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            this.shaderProgram = gl.createProgram();

            gl.shaderSource(vertexShader, Plexx.Rectangle.vertexShaderSource);
            gl.compileShader(vertexShader);

            gl.shaderSource(fragmentShader, Plexx.Rectangle.fragmentShaderSource);
            gl.compileShader(fragmentShader);

            gl.attachShader(this.shaderProgram, vertexShader);
            gl.attachShader(this.shaderProgram, fragmentShader);
            gl.linkProgram(this.shaderProgram);
        }

        public initWebGlBuffers(renderContext: RenderContext) {
            let gl = <WebGLRenderingContext> renderContext.getWebGLRenderingContext();
            this.buffer = gl.createBuffer();
        }

        public initWebGlTextures(renderContext: Plexx.RenderContext) {

        }
    }
}
