namespace Plexx {
    export interface RectangleInterface extends Plexx.TransformationsInterface {
        width: number;
        height: number;
        position: number[];
        colour?: string;
        borderColour?: string;
        borderWidth?: number;
    }

    export class Rectangle extends Plexx.PrimitiveNode {
        public width: number;
        public height: number;
        public position: Mathlib.Vec2;
        public colour: string;
        public borderColour: string;
        public borderWidth: number;

        private colourNode: Colour;
        private borderColourNode: Plexx.Colour;

        constructor(values: RectangleInterface) {
            super("Rectangle", values);

            this.width = values.width;
            this.height = values.height;
            this.position = new Mathlib.Vec2(values.position[0], values.position[1]);

            this.colour = values.colour || "green";
            this.colourNode = new Colour(this.colour);

            this.borderColour = values.borderColour || "#00000000";
            this.borderWidth = values.borderWidth;
            this.borderColourNode = new Colour(this.borderColour);

            console.log("[PLEXX] " + this.toString() + " created");
        }

        public setColour(colour: string) {
            this.colourNode.setColour(colour);
        }

        public clone(): Rectangle {
            return new Rectangle({
                width: this.width,
                height: this.height,
                position: [this.position[0], this.position[1]],
                colour: this.colour,
                translation: this.translation,
                scale: this.scale,
                scalePoint: this.scalePoint,
                rotation: this.rotation,
                rotationPoint: this.rotationPoint
            });
        }

        public toString(): string {
            let rectangleString = this.getName() + " { ";
            rectangleString += "width: " + this.width + "; ";
            rectangleString += "height: " + this.height + "; ";
            rectangleString += "position: " + this.position + "; ";
            rectangleString += "colour: " + this.colour + "; ";
            rectangleString += "translation: " + this.translation + "; ";
            rectangleString += "translation: " + this.translation + "; ";
            rectangleString += "scale: " + this.scale + "; ";
            rectangleString += "rotation: " + this.rotation + "; ";
            rectangleString += "}";
            return rectangleString;
        }

        public hitBox(renderContext: RenderContext, position: Plexx.Mathlib.Vec2): boolean {
            let x: number = position.x;
            let y: number = position.y;

            return (x >= this.position.x && x <= this.position.x + this.width && y >= this.position.y && y <= this.position.y + this.height);
        }

        public getBoundingBox(): Plexx.BoundingBox2d {
            let min: Mathlib.Vec2 = new Mathlib.Vec2(0, 0);
            let max: Mathlib.Vec2 = new Mathlib.Vec2(0, 0);
            let boundingBox: BoundingBox2d = null;

            console.log("Rectangle", boundingBox);
            min.x = this.position.x;
            min.y = this.position.y;

            max.x = this.position.x + this.width;
            max.y = this.position.y + this.height;
            console.log("Rectangle", max, min);

            boundingBox = new BoundingBox2d(min, max);
            console.log("Rectangle", boundingBox);

            return boundingBox;
        }

        public updateCanvas2d(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let context = renderContext.getCanvas2D().getContext("2d");
            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = preTransformationMatrix.copy().multiply(mirrorMatrix);

            context.save();
            context.setTransform(resultMatrix.at(0), resultMatrix.at(1), resultMatrix.at(3), resultMatrix.at(4), resultMatrix.at(6), resultMatrix.at(7));
            context.fillStyle = this.colourNode.getCss3String();
            context.fillRect(this.position.x, this.position.y, this.width, this.height);
            context.strokeStyle = this.borderColourNode.getCss3String();
            context.lineWidth = this.borderWidth;
            context.strokeRect(this.position[0], this.position[1], this.width, this.height);
            context.restore();

            return true;
        }

        public generateSvg(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): XMLTag {
            let xmlTag = new XMLTag("rect");

            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
            let resultMatrix: Plexx.Mathlib.Mat3 = preTransformationMatrix.copy().multiply(mirrorMatrix);

            xmlTag.addAttribute("width", String(this.width));
            xmlTag.addAttribute("height", String(this.height));
            xmlTag.addAttribute("x", String(this.position.x));
            xmlTag.addAttribute("y", String(this.position.y));
            xmlTag.addAttribute("fill", String(this.colourNode.getCss3String()));
            xmlTag.addAttribute("stroke", "none");
            xmlTag.addAttribute("transform", "matrix(" + resultMatrix.at(0) + " " + resultMatrix.at(1) + " " + resultMatrix.at(3) + " " + resultMatrix.at(4) + " " + resultMatrix.at(6) + " " + resultMatrix.at(7) + ")");

//            xmlTag.addAttribute("onclick", "Plexx.svgEventLookup(" + "\"click\"" + ", \"" + renderContext.getId() + "\", " + this.getNodeId() + ")");
//            xmlTag.addAttribute("onmouseover", "Plexx.svgEventLookup(" + "\"mousein\"" + ", \"" + renderContext.getId() + "\", " + this.getNodeId() + ")");
//            xmlTag.addAttribute("onmouseout", "Plexx.svgEventLookup(" + "\"mouseout\"" + ", \"" + renderContext.getId() + "\", " + this.getNodeId() + ")");

            return xmlTag;
        }

        public updateWebGl(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): boolean {
            let gl = <WebGLRenderingContext> renderContext.getWebGLRenderingContext();
            gl.useProgram(this.shaderProgram);

            this.shaderProgram.resolutionLocation = gl.getUniformLocation(this.shaderProgram, "resolution");
            this.shaderProgram.matrix = gl.getUniformLocation(this.shaderProgram, "matrix");
            this.shaderProgram.vertexPositionAttribute = gl.getAttribLocation(this.shaderProgram, "aVertexPosition");
            this.shaderProgram.colourValues = gl.getUniformLocation(this.shaderProgram, "colour");

            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

//            let matrixSize = gl.getUniformLocation(shaderProgram, "resolution");
//            gl.uniform1f(matrixSize, 1);

            let x: number = this.position.x;
            let y: number = this.position.y;
            let w: number = this.width;
            let h: number = this.height;

            gl.bufferData(gl.ARRAY_BUFFER,
                new Float32Array([
                    x, y,
                    x + w, y,
                    x, y + h,
                    x, y + h,
                    x + w, y,
                    x + w, y + h]), gl.STATIC_DRAW);


            gl.uniform2f(this.shaderProgram.resolutionLocation, renderContext.getWidth(), renderContext.getHeight());
            let tM = new Float32Array(preTransformationMatrix.all());
            gl.uniformMatrix3fv(this.shaderProgram.matrix, false, tM);
            gl.uniform4f(this.shaderProgram.colourValues, this.colourNode.getR(), this.colourNode.getG(), this.colourNode.getB(), this.colourNode.getA());
            gl.vertexAttribPointer(this.shaderProgram.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(this.shaderProgram.vertexPositionAttribute);

            gl.drawArrays(gl.TRIANGLES, 0, 6);

            return true;
        }
    }
}
