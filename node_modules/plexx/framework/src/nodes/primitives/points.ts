/// <reference path="../../helper/references.ts" />

namespace Plexx {

    export interface PointsInterface extends Plexx.TransformationsInterface {
        points: number[];
        type: Constants.PointsType;
        size: number;
        colour: string;
        borderSize?: number;
    }

    export class Points extends Plexx.Group implements PointsInterface {

        public points:number[];
        public type:Constants.PointsType;
        public colour:string;
        public size:number;
        public borderSize:number;

        private colourNode:Colour;

        private static defaultBorderSize = 5;


        constructor(values:PointsInterface) {
            super({name: "Points"});
            this.type = values.type || Constants.POINTS_DEFAULT_TYPE_ID;
            this.size = values.size || Constants.POINTS_DEFAULT_SIZE;
            this.colour = values.colour;
            this.colourNode = new Colour(this.colour);
            this.points = values.points;
            this.borderSize = values.borderSize || Plexx.Points.defaultBorderSize;

            if (this.type == Constants.PointsType.HollowDiamond) {
                for (var i = 0; i < this.points.length / 2; i++) {
                    this.add(new Plexx.Rectangle({
                        width: this.size,
                        height: this.size,
                        position: [this.points[2 * i] - this.size/2, this.points[2 * i + 1] - this.size/2],
                        colour: "#00000000",
                        borderColour: this.colour,
                        borderWidth: 5,
                        rotation: 45.0,
                        rotationPoint: [this.points[2 * i], this.points[2* i + 1]]
                    }));
                }
            }
            else if (this.type == Constants.PointsType.HollowCircle) {
                for (var i = 0; i < this.points.length / 2; i++) {
                    console.log(i);
                    this.add(new Plexx.Circle({
                        radius: this.size / 2,
                        colour: "#00000000",
                        borderColour: this.colour,
                        borderWidth: 5,
                        position: [this.points[2 * i], this.points[2 * i + 1]],
                    }));
                }
            }
        }

        public setColour(colour:string) {
            this.colour = colour;
            this.colourNode = new Colour(this.colour);
        }

//        public generateSvg(renderContext:RenderContext, transformationMatrix:Plexx.Mathlib.Mat3):XMLTag {
//            let points;
//
//            let mirrorMatrix:Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
//            let resultMatrix:Plexx.Mathlib.Mat3 = mirrorMatrix.copy().multiply(transformationMatrix);
//
//            if (this.type == Constants.PointsType.HollowCircle) {
//                let xmlTag = new XMLTag("circle");
//                for (var i = 0; i < this.points.length / 2; i++) {
//                    let SVGPoint = document.createElementNS(Constants.SVG_NAMESPACE, "circle");
//                    let x = this.points[2 * i];
//                    let y = this.points[2 * i + 1];
//
//                    xmlTag.addAttribute("transform", "matrix(" + resultMatrix.at(0) + " " + resultMatrix.at(1) + " " + resultMatrix.at(3) + " " + resultMatrix.at(4) + " " + resultMatrix.at(6) + " " + resultMatrix.at(7) + ")");
//                    xmlTag.addAttribute("r", String(this.size));
//                    xmlTag.addAttribute("cx", String(x));
//                    xmlTag.addAttribute("cy", String(y));
//                    xmlTag.addAttribute("fill", "none");
//                    xmlTag.addAttribute("stroke", this.colourNode.getCss3String());
//                    renderContext.getSVG().appendChild(SVGPoint);
//                }
//            }
//            else if (this.type == Constants.PointsType.HollowDiamond) {
//                for (var i = 0; i < this.points.length / 2; i++) {
//                    let x:number = this.points[2 * i]
//                    let y:number = this.points[2 * i + 1];
//                    let s = this.size;
//                    let SVGPoint = document.createElementNS(Constants.SVG_NAMESPACE, "rect");
//
//                    SVGPoint.setAttribute("transform", "matrix(" + resultMatrix.at(0) + " " + resultMatrix.at(1) + " " + resultMatrix.at(3) + " " + resultMatrix.at(4) + " " + resultMatrix.at(6) + " " + resultMatrix.at(7) + ") rotate(45, " + (x) + " ," + (y) + ")");
//                    SVGPoint.setAttribute("width", String(s));
//                    SVGPoint.setAttribute("height", String(s));
//                    SVGPoint.setAttribute("x", String(x - s / 2));
//                    SVGPoint.setAttribute("y", String(y - s / 2));
//                    SVGPoint.setAttribute("fill", "none");
//                    SVGPoint.setAttribute("stroke", this.colourNode.getCss3String());
//                    renderContext.getSVG().appendChild(SVGPoint);
//                }
//            }
//
//            return true;
//        }

//        protected updateWebGl(renderContext:RenderContext, transformationMatrix:Plexx.Mathlib.Mat3):boolean {
//            let gl = <WebGLRenderingContext> renderContext.getCanvasWebGL().getContext("webgl");
//            // vertex shader
//            let vertexShader = gl.createShader(gl.VERTEX_SHADER);
//            gl.shaderSource(vertexShader, this.generateVertexShaderSource());
//            gl.compileShader(vertexShader);
//
//            // fragment shader
//            let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
//            gl.shaderSource(fragmentShader, this.generateFragmentShaderSource());
//            gl.compileShader(fragmentShader);
//
//            // shaderProgram
//            let shaderProgram = gl.createProgram();
//            gl.attachShader(shaderProgram, vertexShader);
//            gl.attachShader(shaderProgram, fragmentShader);
//            gl.linkProgram(shaderProgram);
//            gl.useProgram(shaderProgram);
//            let positionLocation = gl.getAttribLocation(shaderProgram, "aVertexPosition");
//
//            // buffer
//            let buffer = gl.createBuffer();
//            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
//            let resolutionLocation = gl.getUniformLocation(shaderProgram, "resolution");
//            let rotationLocation = gl.getUniformLocation(shaderProgram, "rotation");
//            gl.uniform2f(resolutionLocation, renderContext.getCanvasWebGL().getAttribute("width"), renderContext.getCanvasWebGL().getAttribute("height"));
//            gl.uniform2f(rotationLocation, 0, 1);
//
//            let tM = new Float32Array(this.getTransformationMatrix().all());
//            let matrix = gl.getUniformLocation(shaderProgram, "matrix");
//            gl.uniformMatrix3fv(matrix, false, tM);
//
//            if (this.type == Constants.PointsType.HollowCircle) {
//                for (var i:number = 0; i < this.getPoints().length; i++) {
//                    let currentPosition = this.getPoints()[i];
//                    let n:number = Constants.PRIMITIVES_POINTS_CIRCLE_SIDES;
//                    let s:number = this.size;
//                    let polygonVertices = new Float32Array(2 * n);
//
//                    for (var j = 0; j < n; j++) {
//                        polygonVertices[2 * j] = s * Mathlib.cos(2 * (Mathlib.PI / n) * j) + currentPosition.x;
//                        polygonVertices[(2 * j) + 1] = s * Mathlib.sin(2 * (Mathlib.PI / n) * j) + currentPosition.y;
//                    }
//
//                    gl.bufferData(gl.ARRAY_BUFFER, polygonVertices, gl.STATIC_DRAW);
//                    gl.enableVertexAttribArray(positionLocation);
//                    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
//                    gl.drawArrays(gl.LINE_LOOP, 0, n);
//                }
//            }
//            else if (this.type == Constants.PointsType.HollowDiamond) {
//                for (var i:number = 0; i < this.getPoints().length; i++) {
//                    let currentPosition = this.getPoints()[i];
//                    let n:number = Constants.PRIMITIVES_POINTS_CIRCLE_SIDES;
//                    let s:number = this.size;
//                    let polygonVertices = new Float32Array(2 * n);
//
//                    for (var j = 0; j <= 4; j++) {
//                        polygonVertices[2 * j] = Mathlib.sqrt(2) * (s / 2) * Mathlib.cos(2 * (Mathlib.PI / 4) * j) + currentPosition.x;
//                        polygonVertices[(2 * j) + 1] = Mathlib.sqrt(2) * (s / 2) * Mathlib.sin(2 * (Mathlib.PI / 4) * j) + currentPosition.y;
//                    }
//
//                    gl.bufferData(gl.ARRAY_BUFFER, polygonVertices, gl.STATIC_DRAW);
//                    gl.enableVertexAttribArray(positionLocation);
//                    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
//                    gl.drawArrays(gl.LINE_LOOP, 0, 4);
//                    gl.lineWidth(1);
//                }
//            }
//            return true;
//        }

        /*
         protected generateVertexShaderSource():string {
         let vertexShaderSource =
         "attribute Vec2 aVertexPosition;                             \n" +
         "                                                            \n" +
         "uniform Vec2 resolution;                                    \n" +
         "uniform Vec2 rotation;                                      \n" +
         "uniform Vec2 translation;                                      \n" +
         "                                                            \n" +
         "uniform Mat3 matrix;                                          \n" +
         "                                                              \n" +
         "void main() {                                                 \n" +
         "  Vec2 pos = (matrix * Vec3(aVertexPosition, 1)).xy;          \n" +
         "  Vec2 rotatedPosition = Vec2(                              \n" +
         "       aVertexPosition.x * rotation.y + pos.y * rotation.x,           \n" +
         "       aVertexPosition.y * rotation.y - pos.x * rotation.x);          \n" +
         "  Vec2 position = rotatedPosition + translation;                 \n" +
         "  Vec2 tmp1 = position / resolution;                 \n" +
         "  Vec2 tmp2 = tmp1 * 2.0;                                   \n" +
         "  Vec2 tmp3 = tmp2 - 1.0;                                   \n" +
         "  gl_Position = vec4(tmp3, 0, 1);             \n" +
         "}                                                           \n";

         return vertexShaderSource;
         }

         protected generateFragmentShaderSource():string {
         let fragmentShaderSrc =
         "precision mediump float;                                    \n" +
         "                                                            \n" +
         "void main() {                                               \n" +
         "  gl_FragColor = vec4(" +
         this.borderColour.getR() + ", " +
         this.borderColour.getG() + ", " +
         this.borderColour.getB() + ", " +
         this.borderColour.getA() + ");                               \n" +
         "}                                                           \n";

         return fragmentShaderSrc;
         }

         public toSVGString():string {
         let svgString:string = "";

         if (this.type == Constants.PointsType.HollowCircle) {
         for (var i = 0; i < this.getPoints().length; i++) {
         let xmlTag = new XMLTag("circle");
         let x = this.getPoints()[i].x;
         let y = this.getPoints()[i].y;
         let s = this.size;

         xmlTag.addAttribute("r", String(s));
         xmlTag.addAttribute("cx", String(x));
         xmlTag.addAttribute("cy", String(y));
         xmlTag.addAttribute("fill", "none");
         xmlTag.addAttribute("stroke", "" + this.borderColour.getRGBString());
         svgString += xmlTag.getEmptyElementTag() + "\n";
         }
         }
         else if (this.type == Constants.PointsType.HollowDiamond) {
         for (var i = 0; i < this.getPoints().length; i++) {
         let xmlTag = new XMLTag("rect");
         let x = this.getPoints()[i].x;
         let y = this.getPoints()[i].y;
         let s = this.size;

         xmlTag.addAttribute("width", String(s));
         xmlTag.addAttribute("height", String(s));
         xmlTag.addAttribute("x", String(x));
         xmlTag.addAttribute("y", String(y));
         xmlTag.addAttribute("fill", "none");
         xmlTag.addAttribute("stroke", "" + this.borderColour.getRGBString());
         xmlTag.addAttribute("transform", "rotate(45, " + (x + (s / 2)) + " ," + (y + (s / 2)) + ")");
         svgString += xmlTag.getEmptyElementTag() + "\n";
         }
         }
         return svgString;
         }

         public copy():Points {
         return new Points(this.getPointsAsArray(), this.type, this.size, this.borderColour.getRGBAString());
         }
         */
    }

}
