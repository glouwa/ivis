/// <reference path="../helper/references.ts" />

namespace Plexx {

    export interface GroupInterface extends TransformationsInterface {
        name?: string;
        draggable?: boolean;
        draggingSpace?: number[];
        isDragging?: boolean;
    }

    export interface GroupVisitorInterface {
        executeClickEvent(): void;
        on(mouseEventName: string, callback: (e: any) => {}): any;
        eventMap: { [eventName: string]: (e: any) => void; };
        mouseOver: boolean;
        mouseOverExecuted: boolean;
    }


    export class Group extends Plexx.CompositeNode implements GroupVisitorInterface {
        public translationNode: Plexx.TranslationNode;
        public rotationNode: Plexx.RotationNode;
        public scaleNode: Plexx.ScaleNode;

        eventMap: { [eventName: string]: (e: any) => void; };

        translation: number[];
        scale: number[];
        rotation: number;
        scalePoint: number[];
        rotationPoint: number[];

        isHidden: boolean;
        isDragging: boolean;
        draggable: boolean;

        draggingSpace: number[];
        draggingPoint: Mathlib.Vec2;

        mouseOver: boolean;
        mouseOverExecuted: boolean;

        constructor(values: Plexx.GroupInterface) {
            super(values.name || "Group");

            this.translation = values.translation || [0, 0];
            this.scale = values.scale || [1, 1];
            this.rotation = values.rotation || 0;
            this.scalePoint = values.scalePoint || [0, 0];
            this.rotationPoint = values.rotationPoint || [0, 0];
            this.scaleNode = new ScaleNode({scale: this.scale, scalePoint: this.scalePoint});
            this.rotationNode = new RotationNode({rotation: this.rotation, rotationPoint: this.rotationPoint});
            this.translationNode = new TranslationNode({translation: this.translation});
            this.eventMap = {};
            this.isHidden = false;
            this.mouseOver = false;
            this.mouseOverExecuted = false;
            this.draggable = values.draggable;
            this.draggingSpace = values.draggingSpace;
            this.isDragging = values.isDragging;
            console.log("[PLEXX] " + "CREATE " + this.toString());
        }

        public on(eventName: string, callback: (e: any) => void) {
            this.eventMap[eventName] = callback;
            console.log("group ADD EVENT");
        }

        public hitBox(renderContext: Plexx.RenderContext, mousePosition: Plexx.Mathlib.Vec2) {
            return false;
        }

        public executeClickEvent() {
            console.log("YEAH I WAS CLICKED!");
        }

        public toString(): string {
            let groupString = this.getName() + " { ";
            groupString += "translation: " + this.translation + "; ";
            groupString += "scale: " + this.scale + "; ";
            groupString += "rotation: " + this.rotation + "; ";
            groupString += "}";
            return groupString;
        }

        public accept(nodeVisitor: Plexx.NodeVisitorInterface): number {
            return nodeVisitor.visitGroupNode(this);
        }

        public getTranslationNode() {
            return this.translationNode;

        }

        public getRotationNode() {
            return this.rotationNode;

        }

        public getScaleNode() {
            return this.scaleNode;

        }

        public clone() {
            let newGroup = new Plexx.Group({
                translation: this.translation,
                scale: this.scale,
                scalePoint: this.scalePoint,
                rotation: this.rotation,
                rotationPoint: this.rotationPoint
            });

            this.getChildren().forEach(childNode => {
                newGroup.add(childNode.clone());
            });
            return newGroup;

        }

        public setTranslation(translation: number[]) {
            this.translation = translation;
            this.translationNode.translation = translation;
        }

        public addTranslation(translation: number[]) {
            this.translation[0] += translation[0];
            this.translation[1] += translation[1];
            this.translationNode.translation[0] += translation[0];
            this.translationNode.translation[1] += translation[1];
        }

        public setRotation(rotation: number, rotationPoint?: number[]) {
            this.rotation = rotation;
            this.rotationNode.rotation = rotation;
            this.rotationNode.rotationPoint = rotationPoint;
        }

        public addRotation(rotation: number) {
            this.rotation += rotation;
            this.rotationNode.rotation += rotation;
        }

        public setScale(scale: number[]) {
            this.scale = scale;
            this.scaleNode.scale = scale;
        }

        public addScale(scale: number[]) {
            this.scale[0] += scale[0];
            this.scale[1] += scale[1];
            this.scaleNode.scale[0] += scale[0];
            this.scaleNode.scale[1] += scale[1];
        }

        public generateSvg(renderContext: RenderContext, preTransformationMatrix: Plexx.Mathlib.Mat3): XMLTag {
            let xmlTag = new XMLTag("g");

//            let mirrorMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, -1, 0, 0, renderContext.getHeight(), 1]);
//            let resultMatrix: Plexx.Mathlib.Mat3 = preTransformationMatrix.copy().multiply(mirrorMatrix);

            xmlTag.addAttribute("transform", "matrix(" + preTransformationMatrix.at(0) + " " + preTransformationMatrix.at(1) + " " + preTransformationMatrix.at(3) + " " + preTransformationMatrix.at(4) + " " + preTransformationMatrix.at(6) + " " + preTransformationMatrix.at(7) + ")");

            return xmlTag;
        }
    }
}
