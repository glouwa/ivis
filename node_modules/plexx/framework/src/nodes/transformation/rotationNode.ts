/// <reference path="../../helper/references.ts" />

namespace Plexx {

    export interface RotationNodeInterface {
        rotation?: number;
        rotationPoint?: number[];
    }

    export class RotationNode extends TransformationNode {
        public rotation: number;
        public rotationPoint: number[];

        constructor(values: RotationNodeInterface) {
            super("Rotation");
            this.rotation = values.rotation || 0;
            this.rotationPoint = values.rotationPoint || [0, 0];
        }

        public toString(): string {
            let rotationString: string = this.getName() + " { ";
            rotationString += "rotation: " + this.rotation + "; ";
            rotationString += "rotationPoint: " + this.rotationPoint + "; ";
            rotationString += "}";
            return rotationString;
        }

        public getTransformationMatrix(): Plexx.Mathlib.Mat3 {
            let sinR = Math.sin(-this.rotation * Math.PI / 180);
            let cosR = Math.cos(-this.rotation * Math.PI / 180);
            let mTranslate1: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, 1, 0, -this.rotationPoint[0], -this.rotationPoint[1], 1]);
            let mRotate: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([cosR, -sinR, 0, sinR, cosR, 0, 0, 0, 1]);
            let mTranslate2: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, 1, 0, this.rotationPoint[0], this.rotationPoint[1], 1]);
            return mTranslate1.multiply(mRotate).multiply(mTranslate2);
        }

        public getInverseTransformationMatrix(): Plexx.Mathlib.Mat3 {
            let sinR = Math.sin(this.rotation * Math.PI / 180);
            let cosR = Math.cos(this.rotation * Math.PI / 180);
            let mTranslate1: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, 1, 0, -this.rotationPoint[0], -this.rotationPoint[1], 1]);
            let mRotate: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([cosR, -sinR, 0, sinR, cosR, 0, 0, 0, 1]);
            let mTranslate2: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3([1, 0, 0, 0, 1, 0, this.rotationPoint[0], this.rotationPoint[1], 1]);
            return mTranslate1.multiply(mRotate).multiply(mTranslate2);
        }

        public clone(): Plexx.RotationNode {
            return new RotationNode({
                rotation: this.rotation,
                rotationPoint: this.rotationPoint
            });
        }
    }
}
