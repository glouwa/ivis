namespace Plexx.Mathlib {

    export function factorial(n: number) {
        let r: number = 1;
        for (let i = 2; i <= n; i++)
            r = r * i;
        return r;
    }

    export function sortArrayOfPoint2DByX(unsortedPoints: Vec2[]): Vec2[] {
        let sortedPoints = unsortedPoints.slice(0);
        sortedPoints.sort(sortArrayOfPoint2DByXCompare);
        return sortedPoints;
    }

    export function sortArrayOfPoint2DByY(unsortedPoints: Vec2[]): Vec2[] {
        let sortedPoints = unsortedPoints.slice(0);
        sortedPoints.sort(sortArrayOfPoint2DByYCompare);
        return sortedPoints;
    }

    function sortArrayOfPoint2DByXCompare(a: Vec2, b: Vec2): number {
        if (a.x < b.x) return -1;
        if (a.x > b.x) return 1;
        return 0;
    }

    function sortArrayOfPoint2DByYCompare(a: Vec2, b: Vec2): number {
        if (a.y < b.y) return -1;
        if (a.y > b.y) return 1;
        return 0;
    }

    export class Vec2 {
        public x: number = 0;
        public y: number = 0;

        constructor(x: number, y: number) {
            this.x = x;
            this.y = y;
        }
    }

    export class Vec3 {
        public x: number = 0;
        public y: number = 0;
        public z: number = 0;

        constructor(x: number, y: number, z: number) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public add(v0: Vec3) {
            return new Vec3(this.x + v0.x, this.y + v0.y, this.z + v0.z);
        }

        public multiply(n: number) {
            return new Vec3(this.x * n, this.y * n, this.z * n);
        }
    }

    export class Mat3 {
        public values: number[];

        constructor(values?: number[]) {
            if (values) {
                this.values = values;
            }
            else {
                this.values = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            }
        }

        public multiply(multi: Mat3) {
            let result: number[] = [];
            let resultMatrix: Mat3;

            result[0] = this.values[0] * multi.values[0] + this.values[1] * multi.values[3] + this.values[2] * multi.values[6];
            result[1] = this.values[0] * multi.values[1] + this.values[1] * multi.values[4] + this.values[2] * multi.values[7];
            result[2] = this.values[0] * multi.values[2] + this.values[1] * multi.values[5] + this.values[2] * multi.values[8];

            result[3] = this.values[3] * multi.values[0] + this.values[4] * multi.values[3] + this.values[5] * multi.values[6];
            result[4] = this.values[3] * multi.values[1] + this.values[4] * multi.values[4] + this.values[5] * multi.values[7];
            result[5] = this.values[3] * multi.values[2] + this.values[4] * multi.values[5] + this.values[5] * multi.values[8];

            result[6] = this.values[6] * multi.values[0] + this.values[7] * multi.values[3] + this.values[8] * multi.values[6];
            result[7] = this.values[6] * multi.values[1] + this.values[7] * multi.values[4] + this.values[8] * multi.values[7];
            result[8] = this.values[6] * multi.values[2] + this.values[7] * multi.values[5] + this.values[8] * multi.values[8];

            resultMatrix = new Mat3(result);

            return resultMatrix;
        }

        public multiplyVec3(multi: Vec3): Vec3 {
            let result: number[] = [];
            let resultVector: Vec3;

            result[0] = this.values[0] * multi.x + this.values[1] * multi.y + this.values[2] * multi.z;
            result[1] = this.values[3] * multi.x + this.values[4] * multi.y + this.values[5] * multi.z;
            result[2] = this.values[6] * multi.x + this.values[7] * multi.y + this.values[8] * multi.z;

            resultVector = new Vec3(result[0], result[1], result[2]);

            return resultVector;
        }

        public copy(): Plexx.Mathlib.Mat3 {
            return new Plexx.Mathlib.Mat3(this.values);
        }

        public setIdentity() {
            this.values[0] = 1;
            this.values[1] = 0;
            this.values[2] = 0;
            this.values[3] = 0;
            this.values[4] = 1;
            this.values[5] = 0;
            this.values[6] = 0;
            this.values[7] = 0;
            this.values[8] = 1;
            return this;
        }

        public setEmpty() {
            this.values[0] = 0;
            this.values[1] = 0;
            this.values[2] = 0;
            this.values[3] = 0;
            this.values[4] = 0;
            this.values[5] = 0;
            this.values[6] = 0;
            this.values[7] = 0;
            this.values[8] = 0;
            return this;
        }

        public getArray(): number[] {
            return this.values;
        }

        public at(index: number): number {
            return this.values[index];
        }

        public all(): number[] {
            return this.values;
        }

        public inverse(): Plexx.Mathlib.Mat3 {
            let aMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3();
            let bMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3();
            let cMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3();

            let a: number = 0;
            let b: number = 0;
            let c: number = 0;
            let d: number = 0;
            let e: number = 0;
            let f: number = 0;
            let g: number = 0;
            let h: number = 0;
            let i: number = 0;

            a = this.values[0];
            b = this.values[1];
            c = this.values[2];
            d = this.values[3];
            e = this.values[4];
            f = this.values[5];
            g = this.values[6];
            h = this.values[7];
            i = this.values[8];

            aMatrix.values[0] = e * i - f * h;
            aMatrix.values[1] = -(d * i - f * g);
            aMatrix.values[2] = d * h - e * g;

            aMatrix.values[3] = -(b * i - c * h);
            aMatrix.values[4] = a * i - c * g;
            aMatrix.values[5] = -(a * h - b * g);

            aMatrix.values[6] = b * f - c * e;
            aMatrix.values[7] = -(a * f - c * d);
            aMatrix.values[8] = a * e - b * d;

            bMatrix = aMatrix.transpose();

            let detA: number = this.det();

            cMatrix.values[0] = 1 / detA * bMatrix.values[0];
            cMatrix.values[1] = 1 / detA * bMatrix.values[1];
            cMatrix.values[2] = 1 / detA * bMatrix.values[2];

            cMatrix.values[3] = 1 / detA * bMatrix.values[3];
            cMatrix.values[4] = 1 / detA * bMatrix.values[4];
            cMatrix.values[5] = 1 / detA * bMatrix.values[5];

            cMatrix.values[6] = 1 / detA * bMatrix.values[6];
            cMatrix.values[7] = 1 / detA * bMatrix.values[7];
            cMatrix.values[8] = 1 / detA * bMatrix.values[8];

            return cMatrix;
        }

        public det(): number {
            let t1: number;
            let t2: number;
            let t3: number;
            let t4: number;
            let t5: number;
            let t6: number;
            let det: number;

            t1 = this.values[0] * this.values[4] * this.values[8];
            t2 = this.values[1] * this.values[5] * this.values[6];
            t3 = this.values[2] * this.values[3] * this.values[7];
            t4 = this.values[6] * this.values[4] * this.values[2];
            t5 = this.values[7] * this.values[5] * this.values[0];
            t6 = this.values[8] * this.values[3] * this.values[1];

            det = t1 + t2 + t3 - t4 - t5 - t6;

            return det;
        }

        public transpose(): Plexx.Mathlib.Mat3 {
            let aMatrix: Plexx.Mathlib.Mat3 = new Plexx.Mathlib.Mat3();

            aMatrix.values[0] = this.values[0];
            aMatrix.values[1] = this.values[3];
            aMatrix.values[2] = this.values[6];
            aMatrix.values[3] = this.values[1];
            aMatrix.values[4] = this.values[4];
            aMatrix.values[5] = this.values[7];
            aMatrix.values[6] = this.values[2];
            aMatrix.values[7] = this.values[5];
            aMatrix.values[8] = this.values[8];

            return aMatrix;
        }

    }

    export class StackMat3 {
        public stack: Array<Plexx.Mathlib.Mat3>;

        constructor() {
            this.stack = new Array<Plexx.Mathlib.Mat3>();
        }

        public pop(): Plexx.Mathlib.Mat3 {
            return this.stack.pop();
        }

        public push(transformationMatrix: Plexx.Mathlib.Mat3) {
            this.stack.push(transformationMatrix);
        }

        public top(): Plexx.Mathlib.Mat3 {
            return this.stack[this.stack.length - 1];
        }

    }


}

