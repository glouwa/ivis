/// <reference path="helper/references.ts" />

namespace Plexx {

    export class RenderNodeVisitor implements Plexx.NodeVisitorInterface {
        private transformationMatrixStack: Plexx.Mathlib.StackMat3;
        private renderContext: RenderContext;

        constructor(renderContext: RenderContext) {
            this.renderContext = renderContext;
            this.transformationMatrixStack = new Plexx.Mathlib.StackMat3();
            this.transformationMatrixStack.push(new Plexx.Mathlib.Mat3().setIdentity());
        }

        public visitDrawingAreaNode(drawingArea: Plexx.DrawingArea) {
            let currentRenderType = this.renderContext.getRenderType();
            let thisRenderNodeVisitor: RenderNodeVisitor = this;

            this.transformationMatrixStack.push(drawingArea.translationNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(drawingArea.rotationNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(drawingArea.scaleNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));

            if (currentRenderType === RenderType.CANVAS2D) {
                Plexx.DrawingArea.clearCanvas2d(this.renderContext);
                drawingArea.updateCanvas2d(this.renderContext, this.transformationMatrixStack.top());
            }
            else if (currentRenderType === RenderType.SVG) {
                this.renderContext.clearSVG();
                drawingArea.updateSvg(this.renderContext, this.transformationMatrixStack.top());
            }
            else if (currentRenderType === RenderType.WEBGL) {
                drawingArea.updateWebGl(this.renderContext, this.transformationMatrixStack.top());
            }

            drawingArea.getChildren().forEach(childNode => {
                childNode.accept(thisRenderNodeVisitor);
            });

            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
        }

        public visitPrimitiveNode(primitiveNode: Plexx.PrimitiveNodeinterface) {
            let currentRenderType = this.renderContext.getRenderType();

            this.transformationMatrixStack.push(primitiveNode.translationNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(primitiveNode.rotationNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(primitiveNode.scaleNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));


            if (!primitiveNode.isHidden) {
                if (currentRenderType === RenderType.WEBGL) {
                    primitiveNode.updateWebGl(this.renderContext, this.transformationMatrixStack.top());
                }
                else if (currentRenderType === RenderType.CANVAS2D) {
                    primitiveNode.updateCanvas2d(this.renderContext, this.transformationMatrixStack.top());
                }
                else if (currentRenderType === RenderType.SVG) {
                    let svgObject = primitiveNode.generateSvg(this.renderContext, this.transformationMatrixStack.top())
                        .generateSvgElement();
                    this.renderContext.getSVG().appendChild(svgObject);
                }
            }

            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
        }

        public visitTransformationNode(transformationNode: Plexx.TransformationNode) {
            this.transformationMatrixStack.push(transformationNode.getTransformationMatrix());

            transformationNode.getChildren().forEach(childNode => {
                childNode.accept(this);
            });

            this.transformationMatrixStack.pop();
        }

        public visitGroupNode(groupNode: Plexx.Group) {
            let thisRenderNodeVisitor: RenderNodeVisitor = this;

            this.transformationMatrixStack.push(groupNode.translationNode.getTransformationMatrix().multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(groupNode.rotationNode.getTransformationMatrix().multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(groupNode.scaleNode.getTransformationMatrix().multiply(this.transformationMatrixStack.top()));

            if (!groupNode.isHidden) {
                groupNode.getChildren().forEach(childNode => {
                    childNode.accept(thisRenderNodeVisitor);
                });
            }

            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
        }
    }

}