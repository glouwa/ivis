namespace Plexx {
    export class ClickNodeVisitor implements NodeVisitorInterface {
        private renderContext: RenderContext;
        private mouseEvent: MouseEvent;
        private lastEvent: PlexxEvent;
        private event: PlexxEvent;
        private transformationMatrixStack: Mathlib.StackMat3;
        private isAlreadyHoveringAPrimitiveNode = false;
        private drawingAreaMatrixStack: Mathlib.StackMat3;
        private boundingBoxVectors: BoundingBox2d[];
        private nodeCounter: number;
        private eventFound: boolean;

        constructor(renderContext: RenderContext, mouseEvent: MouseEvent, lastEvent: PlexxEvent) {
            this.renderContext = renderContext;
            this.mouseEvent = mouseEvent;
            this.lastEvent = lastEvent;
            this.event = new PlexxEvent("none", new Plexx.Mathlib.Vec2(0, 0));
            this.nodeCounter = 0;

            // init matrix stacks

            this.transformationMatrixStack = new Plexx.Mathlib.StackMat3();
            this.transformationMatrixStack.push(new Plexx.Mathlib.Mat3().setIdentity());

            this.drawingAreaMatrixStack = new Plexx.Mathlib.StackMat3();
            this.drawingAreaMatrixStack.push(new Plexx.Mathlib.Mat3().setIdentity());

            this.boundingBoxVectors = [];
        }

        public visitDrawingAreaNode(drawingArea: Plexx.DrawingArea): any {
            let clickEvent: PlexxEventType = "none";
            this.nodeCounter++;

            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(drawingArea.translationNode.getInverseTransformationMatrix()));
            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(drawingArea.rotationNode.getInverseTransformationMatrix()));
            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(drawingArea.scaleNode.getInverseTransformationMatrix()));


            this.drawingAreaMatrixStack.push(this.drawingAreaMatrixStack.top().multiply(drawingArea.scaleNode.getInverseTransformationMatrix()));


            let mousePosition: Plexx.Mathlib.Vec3 = new Plexx.Mathlib.Vec3(this.mouseEvent.position.x, this.mouseEvent.position.y, 1);
            let mousePositionRelative = this.drawingAreaMatrixStack.top().transpose().multiplyVec3(mousePosition);


            let self: ClickNodeVisitor = this;
            let childrenReverseOrder = drawingArea.getChildren().slice().reverse();

            childrenReverseOrder.forEach(childNode => {
                clickEvent = childNode.accept(self);
            });
            // console.log("visited", this.nodeCounter);

            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();

            this.drawingAreaMatrixStack.pop();

            return new PlexxEvent(clickEvent, new Plexx.Mathlib.Vec2(0, 0));
        }

        public visitGroupNode(groupNode: Plexx.Group): PlexxEventType {
            let self: ClickNodeVisitor = this;
            this.nodeCounter++;
            let eventType: PlexxEventType = "none";
            let groupEventType: PlexxEventType = "none";
            let childsReverseOrder = groupNode.getChildren().slice().reverse();
            let clickEventInChildes: boolean = false;

            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(groupNode.translationNode.getInverseTransformationMatrix()));
            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(groupNode.rotationNode.getInverseTransformationMatrix()));
            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(groupNode.scaleNode.getInverseTransformationMatrix()));

            let mousePosition: Plexx.Mathlib.Vec3 = new Plexx.Mathlib.Vec3(this.mouseEvent.position.x, this.mouseEvent.position.y, 1);
            // let mousePositionTransformed = this.transformationMatrixStack.top().transpose().multiplyVec3(mousePosition);
            let mousePositionRelative = this.drawingAreaMatrixStack.top().transpose().multiplyVec3(mousePosition);
            let draggingPosition = mousePosition;
            let clickEvent: PlexxEventType = "none";


            // if this node is hidden skip subtree traversal
            if (groupNode.isHidden) {
                if (groupNode.mouseOver && groupNode.eventMap["mouseout"]) {
                    this.event.type = "mouseout";
                    groupNode.eventMap["mouseout"](groupNode);
                    groupNode.mouseOver = false;
                }
            }

//            if (this.isAlreadyHoveringAPrimitiveNode) {
//                // console.log("No Hit", primitiveNode);
//                if (groupNode.mouseOver && groupNode.eventMap["mouseout"]) {
//                    this.event.type = "mouseout";
//                    groupNode.eventMap["mouseout"](groupNode);
//                    groupNode.mouseOver = false;
//                }
//                return clickEvent;
//            }

            if (groupNode.isDragging) {
                if (this.mouseEvent.type === "mousemove") {
                    console.log("is dragging");
                    clickEvent = "dragging";

                    let diffX: number = mousePositionRelative.x - groupNode.draggingPoint.x;
                    let diffY: number = mousePositionRelative.y - groupNode.draggingPoint.y;

                    // let boundingBox: Plexx.BoundingBox2d = new BoundingBox2d(new Plexx.Mathlib.Vec2(1, 1), new Plexx.Mathlib.Vec2(3, 3));

                    // TODO: extend to whole transformation matrix
                    // boundingBox.translate(new Mathlib.Vec2(groupNode.translation[0], groupNode.translation[1]));


                    // if (groupNode.draggingSpace && groupNode.draggingSpace.length === 4) {
                    //     if (boundingBox.getMin().x + diffX < groupNode.draggingSpace[0]) {
                    //         diffX = groupNode.draggingSpace[0] - boundingBox.getMin().x;
                    //         mousePositionRelative.x = groupNode.draggingPoint[0] + diffX;
                    //     }
                    //     if (boundingBox.getMax().x + diffX > groupNode.draggingSpace[0] + groupNode.draggingSpace[2]) {
                    //         diffX = groupNode.draggingSpace[0] + groupNode.draggingSpace[2] - boundingBox.getMax().x;
                    //         mousePositionRelative.x = groupNode.draggingPoint[0] + diffX;
                    //     }
                    //     if (boundingBox.getMin().y + diffY < groupNode.draggingSpace[1]) {
                    //         diffY = groupNode.draggingSpace[1] - boundingBox.getMin().y;
                    //         mousePositionRelative.y = groupNode.draggingPoint[1] + diffY;
                    //     }
                    //     if (boundingBox.getMax().y + diffY > groupNode.draggingSpace[1] + groupNode.draggingSpace[3]) {
                    //         diffY = groupNode.draggingSpace[1] + groupNode.draggingSpace[3] - boundingBox.getMax().y;
                    //         mousePositionRelative.y = groupNode.draggingPoint[1] + diffY;
                    //     }
                    // }
                    groupNode.setTranslation([groupNode.translationNode.translation[0] + diffX, groupNode.translationNode.translation[1] + diffY]);

                    groupNode.draggingPoint.x = mousePositionRelative.x;
                    groupNode.draggingPoint.y = mousePositionRelative.y;

                    if (groupNode.eventMap["dragmove"]) {
                        groupNode.eventMap["dragmove"](groupNode);
                    }
                    this.isAlreadyHoveringAPrimitiveNode = true;

                    this.event.type = "dragging";

                    groupNode.isDragging = true;
                    if (groupNode.eventMap["dragmove"]) {
                        groupNode.eventMap["dragmove"](groupNode);
                    }
                    this.transformationMatrixStack.pop();
                    this.transformationMatrixStack.pop();
                    this.transformationMatrixStack.pop();
                    return;
                }
                else if (this.mouseEvent.type === "mouseup") {
                    console.log("is dragging end");
                    let diffX: number = mousePositionRelative.x - groupNode.draggingPoint.x;
                    let diffY: number = mousePositionRelative.y - groupNode.draggingPoint.y;

                    groupNode.setTranslation([groupNode.translationNode.translation[0] + diffX, groupNode.translationNode.translation[1] + diffY]);

                    // let mouseEvent: MouseEvent = new MouseEvent(groupNode.translation[0], groupNode.translation[1]);

                    groupNode.draggingPoint = new Mathlib.Vec2(mousePositionRelative.x, mousePositionRelative.y);
                    this.event.type = "draggingend";
                    groupNode.isDragging = false;
                    groupNode.draggingPoint = null;
                    if (groupNode.eventMap["dragend"]) {
                        groupNode.eventMap["dragend"](groupNode);
                    }
                    this.transformationMatrixStack.pop();
                    this.transformationMatrixStack.pop();
                    this.transformationMatrixStack.pop();
                    return;
                }
            }
            // traverse to every child of this node
            // console.log("- Group: ");
            childsReverseOrder.forEach(childNode => {

                groupEventType = childNode.accept(self);
                // console.log("  - ", childNode.getName(), groupEventType);

                if (groupEventType !== "none" && groupEventType !== "mouseout") {
                    clickEventInChildes = true;
                    this.event.type = groupEventType;

                    if (this.mouseEvent.type === "click") {
                        if (groupNode.eventMap["click"]) {
                            clickEvent = "click";
                            this.event.type = clickEvent;
                            groupNode.eventMap["click"](groupNode);
                        }
                    }
                    else if (this.mouseEvent.type === "mousedown") {
                        if (groupNode.draggable) {
                            groupNode.isDragging = true;
                            groupNode.draggingPoint = new Mathlib.Vec2(mousePositionRelative.x, mousePositionRelative.y);
                            console.log("start dragging");
                        }
                        if (groupNode.eventMap["mousedown"]) {
                            clickEvent = "mousedown";
                            this.event.type = clickEvent;
                            groupNode.eventMap["mousedown"](groupNode);
                        }
                    }
                    else if (this.mouseEvent.type === "mouseup") {
                        if (groupNode.eventMap["mouseup"]) {
                            clickEvent = "mouseup";
                            this.event.type = clickEvent;
                            groupNode.eventMap["mouseup"](groupNode);
                        }
                    }
                    else if (this.mouseEvent.type === "mousemove") {
                        if (groupNode.eventMap["mousemove"]) {
                            clickEvent = "mousemove";
                            this.event.type = clickEvent;
                            groupNode.eventMap["mousemove"](groupNode);
                        }
                    }

                    if (!groupNode.mouseOver) {
                        groupNode.mouseOver = true;
                        if (groupNode.eventMap["mousein"]) {
                            this.event.type = "mousein";
                            groupNode.eventMap["mousein"](groupNode);
                        }
                    }

                }
                else if (groupEventType === "mouseout") {
                    if (groupNode.mouseOver) {
                        groupNode.mouseOver = false;
                        if (groupNode.eventMap["mouseout"]) {
                            groupNode.eventMap["mouseout"](this.mouseEvent);
                        }
                    }
                }
            });

            if (!clickEventInChildes) {
                if (groupNode.mouseOver) {
                    groupNode.mouseOver = false;
                    if (groupNode.eventMap["mouseout"]) {
                        groupNode.eventMap["mouseout"](this.mouseEvent);
                    }
                }
            }

            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();

            return eventType;
        }

        public visitTransformationNode(transformationNode: Plexx.TransformationNode): PlexxEventType {
            let clickEvent: PlexxEventType = "none";
            this.nodeCounter++;

            // push transformations to stack
            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(transformationNode.getInverseTransformationMatrix()));

            // visit all child nodes
            let self = this;
            transformationNode.getChildren().forEach(childNode => {
                childNode.accept(self);
            });

            // pop transformations from stack
            this.transformationMatrixStack.pop();

            return clickEvent;
        }

        public visitPrimitiveNode(primitiveNode: Plexx.PrimitiveNodeinterface): PlexxEventType {
            let clickEvent: PlexxEventType = "none";

            this.nodeCounter++;

            // push transformations to stack
            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(primitiveNode.translationNode.getInverseTransformationMatrix()));
            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(primitiveNode.rotationNode.getInverseTransformationMatrix()));
            this.transformationMatrixStack.push(this.transformationMatrixStack.top().multiply(primitiveNode.scaleNode.getInverseTransformationMatrix()));

            // if (this.eventFound) {
            //    this.boundingBoxVectors.push(primitiveNode.getBoundingBox().transform(this.transformationMatrixStack.top()));
            //    this.transformationMatrixStack.pop();
            //    this.transformationMatrixStack.pop();
            //    this.transformationMatrixStack.pop();
            // }

            let mousePosition: Plexx.Mathlib.Vec3 = new Plexx.Mathlib.Vec3(this.mouseEvent.position.x, this.mouseEvent.position.y, 1);
            let mousePositionRelative = this.drawingAreaMatrixStack.top().transpose().multiplyVec3(mousePosition);
            let mousePositionTransformed = this.transformationMatrixStack.top().transpose().multiplyVec3(mousePosition);

            // console.log("mousePosition: x=", mousePositionTransformed.x, "y=", mousePositionTransformed.y, "event=", this.mouseEvent.type, primitiveNode);

            // check if primitive is inactive
            if (primitiveNode.isHidden || this.isAlreadyHoveringAPrimitiveNode) {
                if (primitiveNode.mouseOver && primitiveNode.eventMap["mouseout"]) {
                    clickEvent = "mouseout";
                    primitiveNode.eventMap["mouseout"](primitiveNode);
                    primitiveNode.mouseOver = false;
                }
            }
            // check if primitive was in dragging state and is still in dragging state
            else if (primitiveNode.isDragging && this.mouseEvent.type === "mousemove") {
                clickEvent = "dragging";

                let diffX: number = mousePositionRelative.x - primitiveNode.draggingPoint.x;
                let diffY: number = mousePositionRelative.y - primitiveNode.draggingPoint.y;

                let boundingBox: Plexx.BoundingBox2d = primitiveNode.getBoundingBox();

                boundingBox.translate(new Mathlib.Vec2(primitiveNode.translationNode.translation[0], primitiveNode.translationNode.translation[1]));

                if (primitiveNode.draggingSpace.length === 4) {
                    if (boundingBox.getMin().x + diffX < primitiveNode.draggingSpace[0]) {
                        diffX = primitiveNode.draggingSpace[0] - boundingBox.getMin().x;
                        mousePositionRelative.x = primitiveNode.draggingPoint.x + diffX;
                    }
                    if (boundingBox.getMax().x + diffX > primitiveNode.draggingSpace[0] + primitiveNode.draggingSpace[2]) {
                        diffX = primitiveNode.draggingSpace[0] + primitiveNode.draggingSpace[2] - boundingBox.getMax().x;
                        mousePositionRelative.x = primitiveNode.draggingPoint.x + diffX;
                    }
                    if (boundingBox.getMin().y + diffY < primitiveNode.draggingSpace[1]) {
                        diffY = primitiveNode.draggingSpace[1] - boundingBox.getMin().y;
                        mousePositionRelative.y = primitiveNode.draggingPoint.y + diffY;
                    }
                    if (boundingBox.getMax().y + diffY > primitiveNode.draggingSpace[1] + primitiveNode.draggingSpace[3]) {
                        diffY = primitiveNode.draggingSpace[1] + primitiveNode.draggingSpace[3] - boundingBox.getMax().y;
                        mousePositionRelative.y = primitiveNode.draggingPoint.y + diffY;
                    }
                }
                primitiveNode.setTranslation([primitiveNode.translationNode.translation[0] + diffX, primitiveNode.translationNode.translation[1] + diffY]);

                primitiveNode.draggingPoint.x = mousePositionRelative.x;
                primitiveNode.draggingPoint.y = mousePositionRelative.y;
                if (primitiveNode.eventMap["dragmove"]) {
                    primitiveNode.eventMap["dragmove"](primitiveNode);
                }
                this.isAlreadyHoveringAPrimitiveNode = true;
            }

            // check if primitive was in dragging state and is no longer in dragging state
            else if (primitiveNode.isDragging && this.mouseEvent.type === "mouseup") {
                clickEvent = "draggingend";
                let diffX: number = mousePositionRelative.x - primitiveNode.draggingPoint.x;
                let diffY: number = mousePositionRelative.y - primitiveNode.draggingPoint.y;

                let boundingBox: Plexx.BoundingBox2d = primitiveNode.getBoundingBox();

                boundingBox.translate(new Mathlib.Vec2(primitiveNode.translationNode.translation[0], primitiveNode.translationNode.translation[1]));

                if (primitiveNode.draggingSpace.length === 4) {
                    if (boundingBox.getMin().x + diffX < primitiveNode.draggingSpace[0]) {
                        diffX = primitiveNode.draggingSpace[0] - boundingBox.getMin().x;
                        mousePositionRelative.x = primitiveNode.draggingPoint.x + diffX;
                    }
                    if (boundingBox.getMax().x + diffX > primitiveNode.draggingSpace[0] + primitiveNode.draggingSpace[2]) {
                        diffX = primitiveNode.draggingSpace[0] + primitiveNode.draggingSpace[2] - boundingBox.getMax().x;
                        mousePositionRelative.x = primitiveNode.draggingPoint.x + diffX;
                    }
                    if (boundingBox.getMin().y + diffY < primitiveNode.draggingSpace[1]) {
                        diffY = primitiveNode.draggingSpace[1] - boundingBox.getMin().y;
                        mousePositionRelative.y = primitiveNode.draggingPoint.y + diffY;
                    }
                    if (boundingBox.getMax().y + diffY > primitiveNode.draggingSpace[1] + primitiveNode.draggingSpace[3]) {
                        diffY = primitiveNode.draggingSpace[1] + primitiveNode.draggingSpace[3] - boundingBox.getMax().y;
                        mousePositionRelative.y = primitiveNode.draggingPoint.y + diffY;
                    }
                }

//                primitiveNode.setTranslation([primitiveNode.translation[0] + diffX, primitiveNode.translation[1] + diffY]);
                primitiveNode.draggingPoint.x = mousePositionRelative.x;
                primitiveNode.draggingPoint.y = mousePositionRelative.y;

                if (primitiveNode.eventMap["dragend"]) {
                    primitiveNode.eventMap["dragend"](primitiveNode);
                }
                primitiveNode.draggingPoint = null;

                primitiveNode.isDragging = false;
                this.isAlreadyHoveringAPrimitiveNode = true;
            }

            else if (primitiveNode.hitBox(this.renderContext, new Plexx.Mathlib.Vec2(mousePositionTransformed.x, mousePositionTransformed.y))) {
//                console.log("1.3");
                clickEvent = "mousein";
                this.isAlreadyHoveringAPrimitiveNode = true;

                if (this.mouseEvent.type === "click") {
                    if (primitiveNode.eventMap["click"]) {
                        clickEvent = "click";
                        this.event.type = clickEvent;
                        primitiveNode.eventMap["click"](primitiveNode);
                    }
                }
                else if (this.mouseEvent.type === "mousedown") {
                    if (primitiveNode.draggable) {
                        primitiveNode.isDragging = true;
                        primitiveNode.draggingPoint = new Mathlib.Vec2(0, 0);
                        primitiveNode.draggingPoint.x = mousePositionRelative.x;
                        primitiveNode.draggingPoint.y = mousePositionRelative.y;
                    }
                    if (primitiveNode.eventMap["mousedown"]) {
                        clickEvent = "mousedown";
                        this.event.type = clickEvent;
                        primitiveNode.eventMap["mousedown"](primitiveNode);
                    }
                }
                else if (this.mouseEvent.type === "mouseup") {
                    if (primitiveNode.eventMap["mouseup"]) {
                        clickEvent = "mouseup";
                        this.event.type = clickEvent;
                        primitiveNode.eventMap["mouseup"](primitiveNode);
                    }
                }
                else if (this.mouseEvent.type === "mousemove") {
                    if (primitiveNode.eventMap["mousemove"]) {
                        clickEvent = "mousemove";
                        this.event.type = clickEvent;
                        primitiveNode.eventMap["mousemove"](primitiveNode);
                    }
                }

                if (!primitiveNode.mouseOver) {
                    primitiveNode.mouseOver = true;
                    if (primitiveNode.eventMap["mousein"]) {
                        clickEvent = "mousein";
                        primitiveNode.eventMap["mousein"](primitiveNode);
                    }
                }
            }
            else if (primitiveNode.mouseOver && primitiveNode.eventMap["mouseout"]) {
                this.event.type = "mouseout";
                primitiveNode.eventMap["mouseout"](primitiveNode);
                primitiveNode.mouseOver = false;
            }

            // if (clickEvent !== "none") this.eventFound = true;
            // pop transformations from stack
            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();

            return clickEvent;
        }
    }
}
