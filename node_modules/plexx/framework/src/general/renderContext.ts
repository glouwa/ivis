namespace Plexx {

    export interface RenderContextInterface {
        id: string;
        renderType?: RenderType;
    }

    export enum RenderType {
        CANVAS2D,
        SVG,
        WEBGL
    }

    export class RenderContext {

        private renderType: RenderType;

        private canvas2D: any;
        private svg: any;
        private canvasWebGL: any;
        private domId: string;
        private canvasNode: Plexx.DrawingArea;
        private width: number;
        private height: number;
        private stylePosition: string;
        private styleTop: string;
        private styleLeft: string;

        constructor(values: RenderContextInterface) {
            const elementOfDomId = document.getElementById(values.id);

            if (elementOfDomId == null) {
                console.log("[FDGL] Can\'t create render context for " + values.id + ". Element in DOM not found!");
            }
            this.domId = values.id;
            this.width = 100; // dummy value
            this.height = 100; // dummy value
            this.changeRenderType(values.renderType || RenderType.CANVAS2D);
        }

        public changeRenderType(renderType: RenderType) {
            const plexxElement = document.getElementById(this.domId);

            // remove current SceneNode
            if (this.renderType === RenderType.CANVAS2D) {
                plexxElement.removeChild(this.canvas2D);
            } else if (this.renderType === RenderType.SVG) {
                plexxElement.removeChild(this.svg);
            } else if (this.renderType === RenderType.WEBGL) {
                plexxElement.removeChild(this.canvasWebGL);
            }

            // init new SceneNode
            if (renderType === RenderType.CANVAS2D) {
                this.initCanvas2D();
                document.getElementById(this.domId).appendChild(this.canvas2D);
            } else if (renderType === RenderType.SVG) {
                this.initSVG();
                document.getElementById(this.domId).appendChild(this.svg);
            } else if (renderType === RenderType.WEBGL) {
                this.initWebGLCanvas();
                document.getElementById(this.domId).appendChild(this.canvasWebGL);
            }

            this.renderType = renderType;
        }

        public getRenderType(): RenderType {
            return this.renderType;
        }

        public initCanvas2D() {
            this.canvas2D = document.createElement("canvas");
            this.canvas2D.id = "canvas";
            this.canvas2D.width = String(this.width);
            this.canvas2D.height = String(this.height);
            this.canvas2D.style.position = this.stylePosition;
            this.canvas2D.style.top = this.styleTop;
            this.canvas2D.style.left = this.styleLeft;
        }

        public clearSVG() {
            while (this.svg.hasChildNodes()) {
                this.svg.removeChild(this.svg.lastChild);
            }
        }

        public initSVG() {
            this.svg = document.createElementNS(Constants.SVG_NAMESPACE, "svg");
            this.svg.viewBox = String("0 0 " + this.width + " " + this.height);
            this.svg.width = String(this.width);
            this.svg.height = String(this.height);
            this.svg.preserveAspectRatio = "none";
            this.svg.setAttributeNS(null, "width", this.width);
            this.svg.setAttributeNS(null, "height", this.height);
            this.svg.setAttributeNS(null, "viewBox", "0 0 " + this.width + " " + this.height);
            this.svg.style.position = this.stylePosition;
            this.svg.style.top = this.styleTop;
            this.svg.style.left = this.styleLeft;
        }

        public initWebGLCanvas() {
            this.canvasWebGL = document.createElement("canvas");
            this.canvasWebGL.setAttribute("id", "webGLCanvas");
            this.canvasWebGL.setAttribute("height", String(this.height));
            this.canvasWebGL.setAttribute("width", String(this.width));
            this.canvasWebGL.style.position = this.stylePosition;
            this.canvasWebGL.style.top = this.styleTop;
            this.canvasWebGL.style.left = this.styleLeft;
        }

        public getId(): string {
            return this.domId;
        }

        public getCanvas2D() {
            return this.canvas2D;
        }

        public getCanvas2dContext() {
            return this.canvas2D.getContext("2d");
        }

        public getSVG() {
            return this.svg;
        }

        public getCanvasWebGL() {
            return this.canvasWebGL;
        }

        public getWebGLRenderingContext(): WebGLRenderingContext {
            let gl: WebGLRenderingContext;

            if (!this.canvasWebGL) {
                this.initWebGLCanvas();
            }
            gl = <WebGLRenderingContext> this.canvasWebGL.getContext("webgl", {stencil: true});

            return gl;
        }

        public getHeight() {
            return this.height;
        }

        public getWidth() {
            return this.width;
        }

        public setHeight(height: number) {
            this.height = height;
            if (this.canvas2D) this.canvas2D.height = String(this.height);
            if (this.svg) {
                this.svg.height = String(this.height);
                this.svg.setAttributeNS(null, "height", this.height);
                this.svg.setAttributeNS(null, "viewBox", "0 0 " + this.width + " " + this.height);
            }
            if (this.canvasWebGL) this.canvasWebGL.setAttribute("height", String(this.height));
        }

        public setWidth(width: number) {
            this.width = width;
            if (this.canvas2D) this.canvas2D.width = String(this.width);
            if (this.svg) {
                this.svg.width = String(this.width);
                this.svg.setAttributeNS(null, "width", this.width);
                this.svg.setAttributeNS(null, "viewBox", "0 0 " + this.width + " " + this.height);
            }
            if (this.canvasWebGL) this.canvasWebGL.setAttribute("width", String(this.width));
        }

        public setCanvasNode(canvasNode: DrawingArea) {
            this.canvasNode = canvasNode;
        }

        public isWebGLEnabled(): boolean {
            let gl: WebGLRenderingContext = null;

            if (this.canvasWebGL == null) this.initWebGLCanvas();
            try {
                gl = this.canvasWebGL.getContext("webgl");
            } catch (x) {
                gl = null;
            }
            return gl != null;
        }

        public getClientWidth(): number {
            return document.getElementById(this.domId).clientWidth;
        }

        public getClientHeight(): number {
            return document.getElementById(this.domId).clientHeight;
        }

        public setStylePosition(stylePosition: string) {
            this.stylePosition = stylePosition;
            if (this.canvas2D) this.canvas2D.style.position = this.stylePosition;
            if (this.svg) this.svg.style.position = this.stylePosition;
            if (this.canvasWebGL) this.canvasWebGL.style.position = this.stylePosition;
        }

        public setStyleTop(styleTop: string) {
            this.styleTop = styleTop;
            if (this.canvas2D) this.canvas2D.style.top = this.styleTop;
            if (this.svg) this.svg.style.top = this.styleTop;
            if (this.canvasWebGL) this.canvasWebGL.style.top = this.styleTop;
        }

        public setStyleLeft(styleLeft: string) {
            this.styleLeft = styleLeft;
            if (this.canvas2D) this.canvas2D.style.left = this.styleLeft;
            if (this.svg) this.svg.style.left = this.styleLeft;
            if (this.canvasWebGL) this.canvasWebGL.style.left = this.styleLeft;
        }
    }

}
