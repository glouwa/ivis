namespace Plexx {

    export class SvgNodeVisitor implements Plexx.NodeVisitorInterface {
        private renderContext: RenderContext;
        public transformationMatrixStack: Plexx.Mathlib.StackMat3;
        private text: string;

        private intentLevel: number = 0;
        private static intendWidth: string = "  ";

        constructor(renderContext: RenderContext) {
            this.renderContext = renderContext;
            this.transformationMatrixStack = new Plexx.Mathlib.StackMat3();
            this.transformationMatrixStack.push(new Plexx.Mathlib.Mat3().setIdentity());
            this.text = "";
        }

        private getCurrentIntent(): string {
            let intentText: string = "";

            for (let index: number = 1; index <= this.intentLevel; index++) {
                intentText += SvgNodeVisitor.intendWidth;
            }

            return intentText;
        }

        public visitGroupNode(groupNode: Plexx.Group): String {
            this.transformationMatrixStack.push(groupNode.translationNode.getTransformationMatrix().multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(groupNode.rotationNode.getTransformationMatrix().multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(groupNode.scaleNode.getTransformationMatrix().multiply(this.transformationMatrixStack.top()));

            let thisSvgNodeVisitor: SvgNodeVisitor = this;
            let text: string = "";
            let nodeText: string = "";

            console.log("Group", this.transformationMatrixStack.top());
            if (!groupNode.isHidden) {
                // text = groupNode.generateSvg(this.renderContext, this.transformationMatrixStack.top()).getStartTag();
                // text += "\n";
                this.intentLevel++;
                groupNode.getChildren().forEach(childNode => {
                    nodeText = childNode.accept(thisSvgNodeVisitor).toString();
                    if (nodeText !== "") {
                        text += this.getCurrentIntent();
                        text += nodeText;
                        text += "\n";
                    }
                });
                this.intentLevel--;

                // text += this.getCurrentIntent() + groupNode.generateSvg(this.renderContext, this.transformationMatrixStack.top()).getEndTag();
            }

            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();

            return text;
        }

        public visitTransformationNode(transformationNode: Plexx.TransformationNode) {
            this.transformationMatrixStack.push(transformationNode.getTransformationMatrix());

            transformationNode.getChildren().forEach(childNode => {
                childNode.accept(this);
            });

            this.transformationMatrixStack.pop();
        }

        public visitDrawingAreaNode(drawingArea: Plexx.DrawingArea): String {
//            drawingArea.updateSvg(this.renderContext, this.transformationMatrixStack.top());
//            this.transformationMatrixStack.push(drawingArea.rotationNode.getTransformationMatrix()
//                .multiply(this.transformationMatrixStack.top()));
//            this.transformationMatrixStack.push(drawingArea.translationNode.getTransformationMatrix()
//                .multiply(this.transformationMatrixStack.top()));
//            this.transformationMatrixStack.push(drawingArea.scaleNode.getTransformationMatrix()
//                .multiply(this.transformationMatrixStack.top()));
//            this.renderContext.setHeight(drawingArea.getHeight());
//            this.renderContext.setWidth(drawingArea.getWidth());

            this.transformationMatrixStack.push(drawingArea.translationNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(drawingArea.rotationNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(drawingArea.scaleNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));

            let thisSvgNodeVisitor: SvgNodeVisitor = this;
            let text: string = "";
            let nodeText: string;

            text = drawingArea.generateSvg(this.renderContext, this.transformationMatrixStack.top()).getStartTag();
            text += "\n";
            text += "  <rect width=\"" + drawingArea.getClientWidth() + "\" height=\"" + drawingArea.getClientHeight() +"\" x=\"0\"" + " y=\"0\"" + " fill=\"" + drawingArea.getBackgroundColor() + "\" transform=\"" + "\"/>\n"

            console.log("DrawingArea", this.transformationMatrixStack.top());

            // add rectangle to get a background

            let xmlTag = new XMLTag("rect");

            xmlTag.addAttribute("width", String(this.renderContext.getWidth()));
            xmlTag.addAttribute("height", String(this.renderContext.getHeight()));
            xmlTag.addAttribute("x", String(0));
            xmlTag.addAttribute("y", String(0));
            xmlTag.addAttribute("fill", String(drawingArea.getColour()));
            xmlTag.addAttribute("stroke", "none");

            text += xmlTag.generateSvgText();

            this.intentLevel++;
            drawingArea.getChildren().forEach(childNode => {
                nodeText = childNode.accept(thisSvgNodeVisitor).toString();
                if (nodeText !== "") {
                    text += this.getCurrentIntent();
                    text += nodeText;
                    text += "\n";
                }
            });
            this.intentLevel--;

            text += drawingArea.generateSvg(this.renderContext, this.transformationMatrixStack.top()).getEndTag();

           this.transformationMatrixStack.pop();
           this.transformationMatrixStack.pop();
           this.transformationMatrixStack.pop();

            return text;
        }

        public visitPrimitiveNode(primitiveNode: Plexx.PrimitiveNodeinterface): String {
            this.transformationMatrixStack.push(primitiveNode.translationNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(primitiveNode.rotationNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));
            this.transformationMatrixStack.push(primitiveNode.scaleNode.getTransformationMatrix()
                .multiply(this.transformationMatrixStack.top()));

            let text: string = "";

            console.log("Primitive", this.transformationMatrixStack.top());
            if (!primitiveNode.isHidden) {
                text = primitiveNode.generateSvg(this.renderContext, this.transformationMatrixStack.top()).generateSvgText();
            }

            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();
            this.transformationMatrixStack.pop();

            return text;
        }
    }

}
